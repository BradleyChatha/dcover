<html>
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
        <style>
            td {
                height: 1rem;
            }

            td.number {
                width: 100px;
            }

            td pre {
                margin: 0 auto;
            }

            pre {
                font-weight: bold;
            }

            pre.covered {
                color: rgb(44, 212, 149);
            }

            pre.uncovered {
                color: rgb(192, 0, 0);
            }

            body {
                color: rgb(80, 80, 80);
                background: black;
                font-size: 18px;
            }

            header * {
                display: flex;
                align-self: center;
                padding-left: 1rem;
            }

            header {
                display: flex;
                flex-direction: row;
                height: 40px;
                width: 100vw;
                border-bottom: solid 1px white;
                margin-bottom: 2rem;
            }
        </style>
    </head>
    <body>
        <div id="app">
            <header>
                <select v-model="filename">
                    <option v-for="f in files" :key="f.file" :value="f.file">
                        {{ f.file }}
                    </option>
                </select>
                <pre>
not tracked
                </pre>
                <pre class="uncovered">
not covered
                </pre>
                <pre class="covered">
covered
                </pre>
            </header>
            <article>
                <table>
                    <tbody>
                        <template v-for="f in files.filter(f => f.file == filename)" :key="f.file">
                            <tr v-for="line in f.lines" :key="line.number">
                                <td class="number">
                                    {{ line.number+1 }}
                                </td>
                                <td class="text">
                                    <pre :class="getClass(line)">{{ line.text }}</pre>
                                </td>
                            </tr>
                        </template>
                    </tbody>
                </table>
            </article>
        </div>
        <script src="https://cdn.jsdelivr.net/npm/vue@2"></script>
        <script>
            app = new Vue({
                el: '#app',
                data: {
                    files: [
                        {file:"source/jansi.d",coverage:80,lines:[{number:0,tracked:false,hits:0,text:"/// Utilities for writing and reading ANSI styled text.",},{number:1,tracked:false,hits:0,text:"module jansi;",},{number:2,tracked:false,hits:0,text:"",},{number:3,tracked:false,hits:0,text:"import std.range : isOutputRange;",},{number:4,tracked:false,hits:0,text:"import std.typecons : Flag;",},{number:5,tracked:false,hits:0,text:"",},{number:6,tracked:false,hits:0,text:"/+++ CONSTANTS +++/",},{number:7,tracked:false,hits:0,text:"",},{number:8,tracked:false,hits:0,text:"version(JANSI_BetterC)",},{number:9,tracked:false,hits:0,text:"{",},{number:10,tracked:false,hits:0,text:"    private enum BetterC = true;",},{number:11,tracked:false,hits:0,text:"}",},{number:12,tracked:false,hits:0,text:"else",},{number:13,tracked:false,hits:0,text:"{",},{number:14,tracked:false,hits:0,text:"    version(D_BetterC)",},{number:15,tracked:false,hits:0,text:"    {",},{number:16,tracked:false,hits:0,text:"        private enum BetterC = true;",},{number:17,tracked:false,hits:0,text:"    }",},{number:18,tracked:false,hits:0,text:"    else",},{number:19,tracked:false,hits:0,text:"    {",},{number:20,tracked:false,hits:0,text:"        private enum BetterC = false;",},{number:21,tracked:false,hits:0,text:"    }",},{number:22,tracked:false,hits:0,text:"}",},{number:23,tracked:false,hits:0,text:"",},{number:24,tracked:false,hits:0,text:"/// Used to determine if an `AnsiColour` is a background or foreground colour.",},{number:25,tracked:false,hits:0,text:"alias IsBgColour = Flag!\"isBg\";",},{number:26,tracked:false,hits:0,text:"",},{number:27,tracked:false,hits:0,text:"/// Used by certain functions to determine if they should only output an ANSI sequence, or output their entire sequence + data.",},{number:28,tracked:false,hits:0,text:"alias AnsiOnly = Flag!\"ansiOnly\";",},{number:29,tracked:false,hits:0,text:"",},{number:30,tracked:false,hits:0,text:"/// An 8-bit ANSI colour - an index into the terminal's colour palette.",},{number:31,tracked:false,hits:0,text:"alias Ansi8BitColour = ubyte;",},{number:32,tracked:false,hits:0,text:"",},{number:33,tracked:false,hits:0,text:"/// The string that starts an ANSI command sequence.",},{number:34,tracked:false,hits:0,text:"immutable ANSI_CSI                = \"\\033[\";",},{number:35,tracked:false,hits:0,text:"",},{number:36,tracked:false,hits:0,text:"/// The character that delimits ANSI parameters.",},{number:37,tracked:false,hits:0,text:"immutable ANSI_SEPARATOR          = ';';",},{number:38,tracked:false,hits:0,text:"",},{number:39,tracked:false,hits:0,text:"/// The character used to denote that the sequence is an SGR sequence.",},{number:40,tracked:false,hits:0,text:"immutable ANSI_COLOUR_END         = 'm';",},{number:41,tracked:false,hits:0,text:"",},{number:42,tracked:false,hits:0,text:"/// The sequence used to reset all styling.",},{number:43,tracked:false,hits:0,text:"immutable ANSI_COLOUR_RESET       = ANSI_CSI~\"0\"~ANSI_COLOUR_END;",},{number:44,tracked:false,hits:0,text:"",},{number:45,tracked:false,hits:0,text:"/// The amount to increment an `Ansi4BitColour` by in order to access the background version of the colour.",},{number:46,tracked:false,hits:0,text:"immutable ANSI_FG_TO_BG_INCREMENT = 10;",},{number:47,tracked:false,hits:0,text:"",},{number:48,tracked:false,hits:0,text:"/+++ COLOUR TYPES +++/",},{number:49,tracked:false,hits:0,text:"",},{number:50,tracked:false,hits:0,text:"/++",},{number:51,tracked:false,hits:0,text:" + Defines what type of colour an `AnsiColour` stores.",},{number:52,tracked:false,hits:0,text:" + ++/",},{number:53,tracked:false,hits:0,text:"enum AnsiColourType",},{number:54,tracked:false,hits:0,text:"{",},{number:55,tracked:false,hits:0,text:"    /// Default, failsafe.",},{number:56,tracked:false,hits:0,text:"    none,",},{number:57,tracked:false,hits:0,text:"",},{number:58,tracked:false,hits:0,text:"    /// 4-bit colours.",},{number:59,tracked:false,hits:0,text:"    fourBit,",},{number:60,tracked:false,hits:0,text:"",},{number:61,tracked:false,hits:0,text:"    /// 8-bit colours.",},{number:62,tracked:false,hits:0,text:"    eightBit,",},{number:63,tracked:false,hits:0,text:"",},{number:64,tracked:false,hits:0,text:"    /// 24-bit colours.",},{number:65,tracked:false,hits:0,text:"    rgb",},{number:66,tracked:false,hits:0,text:"}",},{number:67,tracked:false,hits:0,text:"",},{number:68,tracked:false,hits:0,text:"/++",},{number:69,tracked:false,hits:0,text:" + An enumeration of standard 4-bit colours.",},{number:70,tracked:false,hits:0,text:" +",},{number:71,tracked:false,hits:0,text:" + These colours will have the widest support between platforms.",},{number:72,tracked:false,hits:0,text:" + ++/",},{number:73,tracked:false,hits:0,text:"enum Ansi4BitColour",},{number:74,tracked:false,hits:0,text:"{",},{number:75,tracked:false,hits:0,text:"    black           = 30,",},{number:76,tracked:false,hits:0,text:"    red             = 31,",},{number:77,tracked:false,hits:0,text:"    green           = 32,",},{number:78,tracked:false,hits:0,text:"    /// On Powershell, this is displayed as a very white colour.",},{number:79,tracked:false,hits:0,text:"    yellow          = 33,",},{number:80,tracked:false,hits:0,text:"    blue            = 34,",},{number:81,tracked:false,hits:0,text:"    magenta         = 35,",},{number:82,tracked:false,hits:0,text:"    cyan            = 36,",},{number:83,tracked:false,hits:0,text:"    /// More gray than true white, use `BrightWhite` for true white.",},{number:84,tracked:false,hits:0,text:"    white           = 37,",},{number:85,tracked:false,hits:0,text:"    /// Grayer than `White`.",},{number:86,tracked:false,hits:0,text:"    brightBlack     = 90,",},{number:87,tracked:false,hits:0,text:"    brightRed       = 91,",},{number:88,tracked:false,hits:0,text:"    brightGreen     = 92,",},{number:89,tracked:false,hits:0,text:"    brightYellow    = 93,",},{number:90,tracked:false,hits:0,text:"    brightBlue      = 94,",},{number:91,tracked:false,hits:0,text:"    brightMagenta   = 95,",},{number:92,tracked:false,hits:0,text:"    brightCyan      = 96,",},{number:93,tracked:false,hits:0,text:"    brightWhite     = 97",},{number:94,tracked:false,hits:0,text:"}",},{number:95,tracked:false,hits:0,text:"",},{number:96,tracked:false,hits:0,text:"/++",},{number:97,tracked:false,hits:0,text:" + Contains a 3-byte, RGB colour.",},{number:98,tracked:false,hits:0,text:" + ++/",},{number:99,tracked:false,hits:0,text:"@safe",},{number:100,tracked:false,hits:0,text:"struct AnsiRgbColour",},{number:101,tracked:false,hits:0,text:"{",},{number:102,tracked:false,hits:0,text:"    union",},{number:103,tracked:false,hits:0,text:"    {",},{number:104,tracked:false,hits:0,text:"        /// The RGB components as an array.",},{number:105,tracked:false,hits:0,text:"        ubyte[3] components;",},{number:106,tracked:false,hits:0,text:"",},{number:107,tracked:false,hits:0,text:"        struct {",},{number:108,tracked:false,hits:0,text:"            /// The red component.",},{number:109,tracked:false,hits:0,text:"            ubyte r;",},{number:110,tracked:false,hits:0,text:"",},{number:111,tracked:false,hits:0,text:"            /// The green component.",},{number:112,tracked:false,hits:0,text:"            ubyte g;",},{number:113,tracked:false,hits:0,text:"",},{number:114,tracked:false,hits:0,text:"            /// The blue component.",},{number:115,tracked:false,hits:0,text:"            ubyte b;",},{number:116,tracked:false,hits:0,text:"        }",},{number:117,tracked:false,hits:0,text:"    }",},{number:118,tracked:false,hits:0,text:"",},{number:119,tracked:false,hits:0,text:"    @safe @nogc nothrow pure:",},{number:120,tracked:false,hits:0,text:"",},{number:121,tracked:false,hits:0,text:"    /++",},{number:122,tracked:false,hits:0,text:"     + Construct this colour from 3 ubyte components, in RGB order.",},{number:123,tracked:false,hits:0,text:"     +",},{number:124,tracked:false,hits:0,text:"     + Params:",},{number:125,tracked:false,hits:0,text:"     +  components = The components to use.",},{number:126,tracked:false,hits:0,text:"     + ++/",},{number:127,tracked:true,hits:4,text:"    this(ubyte[3] components)",},{number:128,tracked:false,hits:0,text:"    {",},{number:129,tracked:true,hits:4,text:"        this.components = components;",},{number:130,tracked:false,hits:0,text:"    }",},{number:131,tracked:false,hits:0,text:"",},{number:132,tracked:false,hits:0,text:"    /++",},{number:133,tracked:false,hits:0,text:"     + Construct this colour from the 3 provided ubyte components.",},{number:134,tracked:false,hits:0,text:"     +",},{number:135,tracked:false,hits:0,text:"     + Params:",},{number:136,tracked:false,hits:0,text:"     +  r = The red component.",},{number:137,tracked:false,hits:0,text:"     +  g = The green component.",},{number:138,tracked:false,hits:0,text:"     +  b = The blue component.",},{number:139,tracked:false,hits:0,text:"     + ++/",},{number:140,tracked:true,hits:19,text:"    this(ubyte r, ubyte g, ubyte b)",},{number:141,tracked:false,hits:0,text:"    {",},{number:142,tracked:true,hits:19,text:"        this.r = r;",},{number:143,tracked:true,hits:19,text:"        this.g = g;",},{number:144,tracked:true,hits:19,text:"        this.b = b;",},{number:145,tracked:false,hits:0,text:"    }",},{number:146,tracked:false,hits:0,text:"}",},{number:147,tracked:false,hits:0,text:"",},{number:148,tracked:false,hits:0,text:"private union AnsiColourUnion",},{number:149,tracked:false,hits:0,text:"{",},{number:150,tracked:false,hits:0,text:"    Ansi4BitColour fourBit;",},{number:151,tracked:false,hits:0,text:"    Ansi8BitColour eightBit;",},{number:152,tracked:false,hits:0,text:"    AnsiRgbColour  rgb;",},{number:153,tracked:false,hits:0,text:"}",},{number:154,tracked:false,hits:0,text:"",},{number:155,tracked:false,hits:0,text:"/++",},{number:156,tracked:false,hits:0,text:" + Contains any type of ANSI colour and provides the ability to create a valid SGR command to set the foreground/background.",},{number:157,tracked:false,hits:0,text:" +",},{number:158,tracked:false,hits:0,text:" + This struct overloads `opAssign` allowing easy assignment from `Ansi4BitColour`, `Ansi8BitColour`, `AnsiRgbColour`, and any user-defined type",},{number:159,tracked:false,hits:0,text:" + that satisfies `isUserDefinedRgbType`.",},{number:160,tracked:false,hits:0,text:" + ++/",},{number:161,tracked:false,hits:0,text:"@safe",},{number:162,tracked:false,hits:0,text:"struct AnsiColour",},{number:163,tracked:false,hits:0,text:"{",},{number:164,tracked:false,hits:0,text:"    private static immutable FG_MARKER        = \"38\";",},{number:165,tracked:false,hits:0,text:"    private static immutable BG_MARKER        = \"48\";",},{number:166,tracked:false,hits:0,text:"    private static immutable EIGHT_BIT_MARKER = '5';",},{number:167,tracked:false,hits:0,text:"    private static immutable RGB_MARKER       = '2';",},{number:168,tracked:false,hits:0,text:"",},{number:169,tracked:false,hits:0,text:"    /++",},{number:170,tracked:false,hits:0,text:"     + The maximum amount of characters any singular `AnsiColour` sequence may use.",},{number:171,tracked:false,hits:0,text:"     +",},{number:172,tracked:false,hits:0,text:"     + This is often used to create a static array to temporarily, and without allocation, store the sequence for an `AnsiColour`.",},{number:173,tracked:false,hits:0,text:"     + ++/",},{number:174,tracked:false,hits:0,text:"    enum MAX_CHARS_NEEDED = \"38;2;255;255;255\".length;",},{number:175,tracked:false,hits:0,text:"",},{number:176,tracked:false,hits:0,text:"    private",},{number:177,tracked:false,hits:0,text:"    {",},{number:178,tracked:false,hits:0,text:"        AnsiColourUnion _value;",},{number:179,tracked:false,hits:0,text:"        AnsiColourType  _type;",},{number:180,tracked:false,hits:0,text:"        IsBgColour      _isBg;",},{number:181,tracked:false,hits:0,text:"",},{number:182,tracked:false,hits:0,text:"        @safe @nogc nothrow",},{number:183,tracked:true,hits:0,text:"        this(IsBgColour isBg) pure",},{number:184,tracked:false,hits:0,text:"        {",},{number:185,tracked:true,hits:0,text:"            this._isBg = isBg;",},{number:186,tracked:false,hits:0,text:"        }",},{number:187,tracked:false,hits:0,text:"    }",},{number:188,tracked:false,hits:0,text:"",},{number:189,tracked:false,hits:0,text:"    /// A variant of `.init` that is used for background colours.",},{number:190,tracked:false,hits:0,text:"    static immutable bgInit = AnsiColour(IsBgColour.yes);",},{number:191,tracked:false,hits:0,text:"",},{number:192,tracked:false,hits:0,text:"    /+++ CTORS AND PROPERTIES +++/",},{number:193,tracked:false,hits:0,text:"    @safe @nogc nothrow pure",},{number:194,tracked:false,hits:0,text:"    {",},{number:195,tracked:false,hits:0,text:"        // Seperate, non-templated constructors as that's a lot more documentation-generator-friendly.",},{number:196,tracked:false,hits:0,text:"",},{number:197,tracked:false,hits:0,text:"        /++",},{number:198,tracked:false,hits:0,text:"         + Construct a 4-bit colour.",},{number:199,tracked:false,hits:0,text:"         +",},{number:200,tracked:false,hits:0,text:"         + Params:",},{number:201,tracked:false,hits:0,text:"         +  colour = The 4-bit colour to use.",},{number:202,tracked:false,hits:0,text:"         +  isBg   = Determines whether this colour sets the foreground or the background.",},{number:203,tracked:false,hits:0,text:"         + ++/",},{number:204,tracked:true,hits:19,text:"        this(Ansi4BitColour colour, IsBgColour isBg = IsBgColour.no)",},{number:205,tracked:false,hits:0,text:"        {",},{number:206,tracked:true,hits:19,text:"            this = colour;",},{number:207,tracked:true,hits:19,text:"            this._isBg = isBg;",},{number:208,tracked:false,hits:0,text:"        }",},{number:209,tracked:false,hits:0,text:"        ",},{number:210,tracked:false,hits:0,text:"        /++",},{number:211,tracked:false,hits:0,text:"         + Construct an 8-bit colour.",},{number:212,tracked:false,hits:0,text:"         +",},{number:213,tracked:false,hits:0,text:"         + Params:",},{number:214,tracked:false,hits:0,text:"         +  colour = The 8-bit colour to use.",},{number:215,tracked:false,hits:0,text:"         +  isBg   = Determines whether this colour sets the foreground or the background.",},{number:216,tracked:false,hits:0,text:"         + ++/",},{number:217,tracked:true,hits:10,text:"        this(Ansi8BitColour colour, IsBgColour isBg = IsBgColour.no)",},{number:218,tracked:false,hits:0,text:"        {",},{number:219,tracked:true,hits:10,text:"            this = colour;",},{number:220,tracked:true,hits:10,text:"            this._isBg = isBg;",},{number:221,tracked:false,hits:0,text:"        }",},{number:222,tracked:false,hits:0,text:"",},{number:223,tracked:false,hits:0,text:"        /++",},{number:224,tracked:false,hits:0,text:"         + Construct an RGB colour.",},{number:225,tracked:false,hits:0,text:"         +",},{number:226,tracked:false,hits:0,text:"         + Params:",},{number:227,tracked:false,hits:0,text:"         +  colour = The RGB colour to use.",},{number:228,tracked:false,hits:0,text:"         +  isBg   = Determines whether this colour sets the foreground or the background.",},{number:229,tracked:false,hits:0,text:"         + ++/",},{number:230,tracked:true,hits:23,text:"        this(AnsiRgbColour colour, IsBgColour isBg = IsBgColour.no)",},{number:231,tracked:false,hits:0,text:"        {",},{number:232,tracked:true,hits:23,text:"            this = colour;",},{number:233,tracked:true,hits:23,text:"            this._isBg = isBg;",},{number:234,tracked:false,hits:0,text:"        }",},{number:235,tracked:false,hits:0,text:"",},{number:236,tracked:false,hits:0,text:"        /++",},{number:237,tracked:false,hits:0,text:"         + Construct an RGB colour.",},{number:238,tracked:false,hits:0,text:"         +",},{number:239,tracked:false,hits:0,text:"         + Params:",},{number:240,tracked:false,hits:0,text:"         +  r      = The red component.",},{number:241,tracked:false,hits:0,text:"         +  g      = The green component.",},{number:242,tracked:false,hits:0,text:"         +  b      = The blue component.",},{number:243,tracked:false,hits:0,text:"         +  isBg   = Determines whether this colour sets the foreground or the background.",},{number:244,tracked:false,hits:0,text:"         + ++/",},{number:245,tracked:true,hits:13,text:"        this(ubyte r, ubyte g, ubyte b, IsBgColour isBg = IsBgColour.no)",},{number:246,tracked:false,hits:0,text:"        {",},{number:247,tracked:true,hits:13,text:"            this(AnsiRgbColour(r, g, b), isBg);",},{number:248,tracked:false,hits:0,text:"        }",},{number:249,tracked:false,hits:0,text:"",},{number:250,tracked:false,hits:0,text:"        /++",},{number:251,tracked:false,hits:0,text:"         + Construct an RGB colour.",},{number:252,tracked:false,hits:0,text:"         +",},{number:253,tracked:false,hits:0,text:"         + Params:",},{number:254,tracked:false,hits:0,text:"         +  colour = The user-defined colour type that satisfies `isUserDefinedRgbType`.",},{number:255,tracked:false,hits:0,text:"         +  isBg   = Determines whether this colour sets the foreground or the background.",},{number:256,tracked:false,hits:0,text:"         + ++/",},{number:257,tracked:false,hits:0,text:"        this(T)(T colour, IsBgColour isBg = IsBgColour.no)",},{number:258,tracked:false,hits:0,text:"        if(isUserDefinedRgbType!T)",},{number:259,tracked:false,hits:0,text:"        {",},{number:260,tracked:false,hits:0,text:"            this = colour;",},{number:261,tracked:false,hits:0,text:"            this._isBg = isBg;",},{number:262,tracked:false,hits:0,text:"        }",},{number:263,tracked:false,hits:0,text:"",},{number:264,tracked:false,hits:0,text:"        /++",},{number:265,tracked:false,hits:0,text:"         + Allows direct assignment from any type that can also be used in any of this struct's ctors.",},{number:266,tracked:false,hits:0,text:"         + ++/",},{number:267,tracked:false,hits:0,text:"        auto opAssign(T)(T colour) return",},{number:268,tracked:false,hits:0,text:"        if(!is(T == typeof(this)))",},{number:269,tracked:false,hits:0,text:"        {",},{number:270,tracked:false,hits:0,text:"            static if(is(T == Ansi4BitColour))",},{number:271,tracked:false,hits:0,text:"            {",},{number:272,tracked:true,hits:19,text:"                this._value.fourBit = colour;",},{number:273,tracked:true,hits:19,text:"                this._type = AnsiColourType.fourBit;",},{number:274,tracked:false,hits:0,text:"            }",},{number:275,tracked:false,hits:0,text:"            else static if(is(T == Ansi8BitColour))",},{number:276,tracked:false,hits:0,text:"            {",},{number:277,tracked:true,hits:10,text:"                this._value.eightBit = colour;",},{number:278,tracked:true,hits:10,text:"                this._type = AnsiColourType.eightBit;",},{number:279,tracked:false,hits:0,text:"            }",},{number:280,tracked:false,hits:0,text:"            else static if(is(T == AnsiRgbColour))",},{number:281,tracked:false,hits:0,text:"            {",},{number:282,tracked:true,hits:23,text:"                this._value.rgb = colour;",},{number:283,tracked:true,hits:23,text:"                this._type = AnsiColourType.rgb;",},{number:284,tracked:false,hits:0,text:"            }",},{number:285,tracked:false,hits:0,text:"            else static if(isUserDefinedRgbType!T)",},{number:286,tracked:false,hits:0,text:"            {",},{number:287,tracked:false,hits:0,text:"                this = colour.to!AnsiColour();",},{number:288,tracked:false,hits:0,text:"            }",},{number:289,tracked:false,hits:0,text:"            else static assert(false, \"Cannot implicitly convert \"~T.stringof~\" into an AnsiColour.\");",},{number:290,tracked:false,hits:0,text:"            ",},{number:291,tracked:true,hits:52,text:"            return this;",},{number:292,tracked:false,hits:0,text:"        }",},{number:293,tracked:false,hits:0,text:"",},{number:294,tracked:false,hits:0,text:"        /// Returns: The `AnsiColourType` of this `AnsiColour`.",},{number:295,tracked:false,hits:0,text:"        @property",},{number:296,tracked:false,hits:0,text:"        AnsiColourType type() const",},{number:297,tracked:false,hits:0,text:"        {",},{number:298,tracked:true,hits:133,text:"            return this._type;",},{number:299,tracked:false,hits:0,text:"        }",},{number:300,tracked:false,hits:0,text:"",},{number:301,tracked:false,hits:0,text:"        /// Returns: Whether this `AnsiColour` is for a background or not (it affects the output!).",},{number:302,tracked:false,hits:0,text:"        @property",},{number:303,tracked:false,hits:0,text:"        IsBgColour isBg() const",},{number:304,tracked:false,hits:0,text:"        {",},{number:305,tracked:true,hits:32,text:"            return this._isBg;",},{number:306,tracked:false,hits:0,text:"        }",},{number:307,tracked:false,hits:0,text:"",},{number:308,tracked:false,hits:0,text:"        /// ditto",},{number:309,tracked:false,hits:0,text:"        @property",},{number:310,tracked:false,hits:0,text:"        void isBg(IsBgColour bg)",},{number:311,tracked:false,hits:0,text:"        {",},{number:312,tracked:true,hits:71,text:"            this._isBg = bg;",},{number:313,tracked:false,hits:0,text:"        }",},{number:314,tracked:false,hits:0,text:"",},{number:315,tracked:false,hits:0,text:"        /// ditto",},{number:316,tracked:false,hits:0,text:"        @property",},{number:317,tracked:false,hits:0,text:"        void isBg(bool bg)",},{number:318,tracked:false,hits:0,text:"        {",},{number:319,tracked:true,hits:0,text:"            this._isBg = cast(IsBgColour)bg;",},{number:320,tracked:false,hits:0,text:"        }",},{number:321,tracked:false,hits:0,text:"",},{number:322,tracked:false,hits:0,text:"        /++",},{number:323,tracked:false,hits:0,text:"        + Assertions:",},{number:324,tracked:false,hits:0,text:"        +  This colour's type must be `AnsiColourType.fourBit`",},{number:325,tracked:false,hits:0,text:"        +",},{number:326,tracked:false,hits:0,text:"        + Returns:",},{number:327,tracked:false,hits:0,text:"        +  This `AnsiColour` as an `Ansi4BitColour`.",},{number:328,tracked:false,hits:0,text:"        + ++/",},{number:329,tracked:false,hits:0,text:"        @property",},{number:330,tracked:false,hits:0,text:"        Ansi4BitColour asFourBit() const",},{number:331,tracked:false,hits:0,text:"        {",},{number:332,tracked:true,hits:0,text:"            assert(this.type == AnsiColourType.fourBit);",},{number:333,tracked:true,hits:0,text:"            return this._value.fourBit;",},{number:334,tracked:false,hits:0,text:"        }",},{number:335,tracked:false,hits:0,text:"",},{number:336,tracked:false,hits:0,text:"        /++",},{number:337,tracked:false,hits:0,text:"        + Assertions:",},{number:338,tracked:false,hits:0,text:"        +  This colour's type must be `AnsiColourType.eightBit`",},{number:339,tracked:false,hits:0,text:"        +",},{number:340,tracked:false,hits:0,text:"        + Returns:",},{number:341,tracked:false,hits:0,text:"        +  This `AnsiColour` as a `ubyte`.",},{number:342,tracked:false,hits:0,text:"        + ++/",},{number:343,tracked:false,hits:0,text:"        @property",},{number:344,tracked:false,hits:0,text:"        ubyte asEightBit() const",},{number:345,tracked:false,hits:0,text:"        {",},{number:346,tracked:true,hits:0,text:"            assert(this.type == AnsiColourType.eightBit);",},{number:347,tracked:true,hits:0,text:"            return this._value.eightBit;",},{number:348,tracked:false,hits:0,text:"        }",},{number:349,tracked:false,hits:0,text:"",},{number:350,tracked:false,hits:0,text:"        /++",},{number:351,tracked:false,hits:0,text:"        + Assertions:",},{number:352,tracked:false,hits:0,text:"        +  This colour's type must be `AnsiColourType.rgb`",},{number:353,tracked:false,hits:0,text:"        +",},{number:354,tracked:false,hits:0,text:"        + Returns:",},{number:355,tracked:false,hits:0,text:"        +  This `AnsiColour` as an `AnsiRgbColour`.",},{number:356,tracked:false,hits:0,text:"        + ++/",},{number:357,tracked:false,hits:0,text:"        @property",},{number:358,tracked:false,hits:0,text:"        AnsiRgbColour asRgb() const",},{number:359,tracked:false,hits:0,text:"        {",},{number:360,tracked:true,hits:0,text:"            assert(this.type == AnsiColourType.rgb);",},{number:361,tracked:true,hits:0,text:"            return this._value.rgb;",},{number:362,tracked:false,hits:0,text:"        }",},{number:363,tracked:false,hits:0,text:"    }",},{number:364,tracked:false,hits:0,text:"    ",},{number:365,tracked:false,hits:0,text:"    /+++ OUTPUT +++/",},{number:366,tracked:false,hits:0,text:"",},{number:367,tracked:false,hits:0,text:"    static if(!BetterC)",},{number:368,tracked:false,hits:0,text:"    {",},{number:369,tracked:false,hits:0,text:"        /++",},{number:370,tracked:false,hits:0,text:"         + [Not enabled in -betterC] Converts this `AnsiColour` into a GC-allocated sequence string.",},{number:371,tracked:false,hits:0,text:"         +",},{number:372,tracked:false,hits:0,text:"         + See_Also:",},{number:373,tracked:false,hits:0,text:"         +  `toSequence`",},{number:374,tracked:false,hits:0,text:"         + ++/",},{number:375,tracked:false,hits:0,text:"        @trusted nothrow",},{number:376,tracked:false,hits:0,text:"        string toString() const",},{number:377,tracked:false,hits:0,text:"        {",},{number:378,tracked:false,hits:0,text:"            import std.exception : assumeUnique;",},{number:379,tracked:false,hits:0,text:"",},{number:380,tracked:true,hits:1,text:"            auto chars = new char[MAX_CHARS_NEEDED];",},{number:381,tracked:true,hits:1,text:"            return this.toSequence(chars[0..MAX_CHARS_NEEDED]).assumeUnique;",},{number:382,tracked:false,hits:0,text:"        }",},{number:383,tracked:false,hits:0,text:"        ///",},{number:384,tracked:false,hits:0,text:"        @(\"AnsiColour.toString\")",},{number:385,tracked:false,hits:0,text:"        unittest",},{number:386,tracked:false,hits:0,text:"        {",},{number:387,tracked:true,hits:1,text:"            assert(AnsiColour(255, 128, 64).toString() == \"38;2;255;128;64\");",},{number:388,tracked:false,hits:0,text:"        }",},{number:389,tracked:false,hits:0,text:"    }",},{number:390,tracked:false,hits:0,text:"",},{number:391,tracked:false,hits:0,text:"    /++",},{number:392,tracked:false,hits:0,text:"     + Creates an ANSI SGR command that either sets the foreground, or the background (`isBg`) to the colour",},{number:393,tracked:false,hits:0,text:"     + stored inside of this `AnsiColour`.",},{number:394,tracked:false,hits:0,text:"     +",},{number:395,tracked:false,hits:0,text:"     + Please note that the CSI (`ANSI_CSI`/`\\033[`) and the SGR marker (`ANSI_COLOUR_END`/`m`) are not included",},{number:396,tracked:false,hits:0,text:"     + in this output.",},{number:397,tracked:false,hits:0,text:"     +",},{number:398,tracked:false,hits:0,text:"     + Notes:",},{number:399,tracked:false,hits:0,text:"     +  Any characters inside of `buffer` that are not covered by the returned slice, are left unmodified.",},{number:400,tracked:false,hits:0,text:"     +",},{number:401,tracked:false,hits:0,text:"     +  If this colour hasn't been initialised or assigned a value, then the returned value is simply `null`.",},{number:402,tracked:false,hits:0,text:"     +",},{number:403,tracked:false,hits:0,text:"     + Params:",},{number:404,tracked:false,hits:0,text:"     +  buffer = The statically allocated buffer used to store the result of this function.",},{number:405,tracked:false,hits:0,text:"     +",},{number:406,tracked:false,hits:0,text:"     + Returns:",},{number:407,tracked:false,hits:0,text:"     +  A slice into `buffer` that contains the output of this function.",},{number:408,tracked:false,hits:0,text:"     + ++/",},{number:409,tracked:false,hits:0,text:"    @safe @nogc",},{number:410,tracked:false,hits:0,text:"    char[] toSequence(ref return char[MAX_CHARS_NEEDED] buffer) nothrow const",},{number:411,tracked:false,hits:0,text:"    {",},{number:412,tracked:true,hits:69,text:"        if(this.type == AnsiColourType.none)",},{number:413,tracked:true,hits:37,text:"            return null;",},{number:414,tracked:false,hits:0,text:"",},{number:415,tracked:true,hits:32,text:"        size_t cursor;",},{number:416,tracked:false,hits:0,text:"",},{number:417,tracked:false,hits:0,text:"        void numIntoBuffer(ubyte num)",},{number:418,tracked:false,hits:0,text:"        {",},{number:419,tracked:true,hits:60,text:"            char[3] text;",},{number:420,tracked:true,hits:60,text:"            const slice = numToStrBase10(text[0..3], num);",},{number:421,tracked:true,hits:60,text:"            buffer[cursor..cursor + slice.length] = slice[];",},{number:422,tracked:true,hits:60,text:"            cursor += slice.length;",},{number:423,tracked:false,hits:0,text:"        }",},{number:424,tracked:false,hits:0,text:"",},{number:425,tracked:true,hits:32,text:"        if(this.type != AnsiColourType.fourBit)",},{number:426,tracked:false,hits:0,text:"        {",},{number:427,tracked:false,hits:0,text:"            // 38; or 48;",},{number:428,tracked:true,hits:20,text:"            auto marker = (this.isBg) ? BG_MARKER : FG_MARKER;",},{number:429,tracked:true,hits:20,text:"            buffer[cursor..cursor+2] = marker[0..$];",},{number:430,tracked:true,hits:20,text:"            cursor += 2;",},{number:431,tracked:true,hits:20,text:"            buffer[cursor++] = ANSI_SEPARATOR;",},{number:432,tracked:false,hits:0,text:"        }",},{number:433,tracked:false,hits:0,text:"",},{number:434,tracked:false,hits:0,text:"        // 4bit, 5;8bit, or 2;r;g;b",},{number:435,tracked:true,hits:32,text:"        final switch(this.type) with(AnsiColourType)",},{number:436,tracked:false,hits:0,text:"        {",},{number:437,tracked:false,hits:0,text:"            case none: assert(false);",},{number:438,tracked:true,hits:12,text:"            case fourBit: ",},{number:439,tracked:true,hits:12,text:"                numIntoBuffer(cast(ubyte)((this.isBg) ? this._value.fourBit + 10 : this._value.fourBit)); ",},{number:440,tracked:true,hits:12,text:"                break;",},{number:441,tracked:false,hits:0,text:"",},{number:442,tracked:true,hits:6,text:"            case eightBit:",},{number:443,tracked:true,hits:6,text:"                buffer[cursor++] = EIGHT_BIT_MARKER;",},{number:444,tracked:true,hits:6,text:"                buffer[cursor++] = ANSI_SEPARATOR;",},{number:445,tracked:true,hits:6,text:"                numIntoBuffer(this._value.eightBit);",},{number:446,tracked:true,hits:6,text:"                break;",},{number:447,tracked:false,hits:0,text:"                ",},{number:448,tracked:true,hits:14,text:"            case rgb:",},{number:449,tracked:true,hits:14,text:"                buffer[cursor++] = RGB_MARKER;",},{number:450,tracked:true,hits:14,text:"                buffer[cursor++] = ANSI_SEPARATOR;",},{number:451,tracked:false,hits:0,text:"",},{number:452,tracked:true,hits:14,text:"                numIntoBuffer(this._value.rgb.r); ",},{number:453,tracked:true,hits:14,text:"                buffer[cursor++] = ANSI_SEPARATOR;",},{number:454,tracked:true,hits:14,text:"                numIntoBuffer(this._value.rgb.g); ",},{number:455,tracked:true,hits:14,text:"                buffer[cursor++] = ANSI_SEPARATOR;",},{number:456,tracked:true,hits:14,text:"                numIntoBuffer(this._value.rgb.b); ",},{number:457,tracked:true,hits:14,text:"                break;",},{number:458,tracked:false,hits:0,text:"        }",},{number:459,tracked:false,hits:0,text:"",},{number:460,tracked:true,hits:32,text:"        return buffer[0..cursor];",},{number:461,tracked:false,hits:0,text:"    }",},{number:462,tracked:false,hits:0,text:"    ///",},{number:463,tracked:false,hits:0,text:"    @(\"AnsiColour.toSequence(char[])\")",},{number:464,tracked:false,hits:0,text:"    unittest",},{number:465,tracked:false,hits:0,text:"    {",},{number:466,tracked:true,hits:1,text:"        char[AnsiColour.MAX_CHARS_NEEDED] buffer;",},{number:467,tracked:false,hits:0,text:"",},{number:468,tracked:false,hits:0,text:"        void test(string expected, AnsiColour colour)",},{number:469,tracked:false,hits:0,text:"        {",},{number:470,tracked:true,hits:6,text:"            const slice = colour.toSequence(buffer);",},{number:471,tracked:true,hits:6,text:"            assert(slice == expected);",},{number:472,tracked:false,hits:0,text:"        }",},{number:473,tracked:false,hits:0,text:"",},{number:474,tracked:true,hits:1,text:"        test(\"32\",               AnsiColour(Ansi4BitColour.green));",},{number:475,tracked:true,hits:1,text:"        test(\"42\",               AnsiColour(Ansi4BitColour.green, IsBgColour.yes));",},{number:476,tracked:true,hits:1,text:"        test(\"38;5;1\",           AnsiColour(Ansi8BitColour(1)));",},{number:477,tracked:true,hits:1,text:"        test(\"48;5;1\",           AnsiColour(Ansi8BitColour(1), IsBgColour.yes));",},{number:478,tracked:true,hits:1,text:"        test(\"38;2;255;255;255\", AnsiColour(255, 255, 255));",},{number:479,tracked:true,hits:1,text:"        test(\"48;2;255;128;64\",  AnsiColour(255, 128, 64, IsBgColour.yes));",},{number:480,tracked:false,hits:0,text:"    }",},{number:481,tracked:false,hits:0,text:"}",},{number:482,tracked:false,hits:0,text:"",},{number:483,tracked:false,hits:0,text:"/+++ MISC TYPES +++/",},{number:484,tracked:false,hits:0,text:"",},{number:485,tracked:false,hits:0,text:"/++",},{number:486,tracked:false,hits:0,text:" + A list of styling options provided by ANSI SGR.",},{number:487,tracked:false,hits:0,text:" +",},{number:488,tracked:false,hits:0,text:" + As a general rule of thumb, assume most of these won't work inside of a Windows command prompt (unless it's the new Windows Terminal).",},{number:489,tracked:false,hits:0,text:" + ++/",},{number:490,tracked:false,hits:0,text:"enum AnsiSgrStyle",},{number:491,tracked:false,hits:0,text:"{",},{number:492,tracked:false,hits:0,text:"    none      = 0,",},{number:493,tracked:false,hits:0,text:"    bold      = 1,",},{number:494,tracked:false,hits:0,text:"    dim       = 2,",},{number:495,tracked:false,hits:0,text:"    italic    = 3,",},{number:496,tracked:false,hits:0,text:"    underline = 4,",},{number:497,tracked:false,hits:0,text:"    slowBlink = 5,",},{number:498,tracked:false,hits:0,text:"    fastBlink = 6,",},{number:499,tracked:false,hits:0,text:"    invert    = 7,",},{number:500,tracked:false,hits:0,text:"    strike    = 9",},{number:501,tracked:false,hits:0,text:"}",},{number:502,tracked:false,hits:0,text:"",},{number:503,tracked:false,hits:0,text:"private template getMaxSgrStyleCharCount()",},{number:504,tracked:false,hits:0,text:"{",},{number:505,tracked:false,hits:0,text:"    import std.traits : EnumMembers;",},{number:506,tracked:false,hits:0,text:"",},{number:507,tracked:false,hits:0,text:"    // Can't even use non-betterC features in CTFE, so no std.conv.to!string :(",},{number:508,tracked:false,hits:0,text:"    size_t numberOfChars(int num)",},{number:509,tracked:false,hits:0,text:"    {",},{number:510,tracked:false,hits:0,text:"        size_t amount;",},{number:511,tracked:false,hits:0,text:"",},{number:512,tracked:false,hits:0,text:"        do",},{number:513,tracked:false,hits:0,text:"        {",},{number:514,tracked:false,hits:0,text:"            amount++;",},{number:515,tracked:false,hits:0,text:"            num /= 10;",},{number:516,tracked:false,hits:0,text:"        } while(num > 0);",},{number:517,tracked:false,hits:0,text:"",},{number:518,tracked:false,hits:0,text:"        return amount;",},{number:519,tracked:false,hits:0,text:"    }",},{number:520,tracked:false,hits:0,text:"",},{number:521,tracked:false,hits:0,text:"    size_t calculate()",},{number:522,tracked:false,hits:0,text:"    {",},{number:523,tracked:false,hits:0,text:"        size_t amount;",},{number:524,tracked:false,hits:0,text:"        static foreach(member; EnumMembers!AnsiSgrStyle)",},{number:525,tracked:false,hits:0,text:"            amount += numberOfChars(cast(int)member) + 1; // + 1 for the semi-colon after.",},{number:526,tracked:false,hits:0,text:"",},{number:527,tracked:false,hits:0,text:"        return amount;",},{number:528,tracked:false,hits:0,text:"    }",},{number:529,tracked:false,hits:0,text:"",},{number:530,tracked:false,hits:0,text:"    enum getMaxSgrStyleCharCount = calculate();",},{number:531,tracked:false,hits:0,text:"}",},{number:532,tracked:false,hits:0,text:"",},{number:533,tracked:false,hits:0,text:"/++",},{number:534,tracked:false,hits:0,text:" + Contains any number of styling options from `AnsiStyleSgr`, and provides the ability to generate",},{number:535,tracked:false,hits:0,text:" + an ANSI SGR command to apply all of the selected styling options.",},{number:536,tracked:false,hits:0,text:" + ++/",},{number:537,tracked:false,hits:0,text:"@safe",},{number:538,tracked:false,hits:0,text:"struct AnsiStyle",},{number:539,tracked:false,hits:0,text:"{",},{number:540,tracked:false,hits:0,text:"    /++",},{number:541,tracked:false,hits:0,text:"     + The maximum amount of characters any singular `AnsiStyle` sequence may use.",},{number:542,tracked:false,hits:0,text:"     +",},{number:543,tracked:false,hits:0,text:"     + This is often used to create a static array to temporarily, and without allocation, store the sequence for an `AnsiStyle`.",},{number:544,tracked:false,hits:0,text:"     + ++/",},{number:545,tracked:false,hits:0,text:"    enum MAX_CHARS_NEEDED = getMaxSgrStyleCharCount!();",},{number:546,tracked:false,hits:0,text:"",},{number:547,tracked:false,hits:0,text:"    private",},{number:548,tracked:false,hits:0,text:"    {",},{number:549,tracked:false,hits:0,text:"        ushort _sgrBitmask; // Each set bit index corresponds to the value from `AnsiSgrStyle`.",},{number:550,tracked:false,hits:0,text:"",},{number:551,tracked:false,hits:0,text:"        @safe @nogc nothrow",},{number:552,tracked:false,hits:0,text:"        int sgrToBit(AnsiSgrStyle style) pure const",},{number:553,tracked:false,hits:0,text:"        {",},{number:554,tracked:true,hits:163,text:"            return 1 << (cast(int)style);",},{number:555,tracked:false,hits:0,text:"        }",},{number:556,tracked:false,hits:0,text:"",},{number:557,tracked:false,hits:0,text:"        @safe @nogc nothrow",},{number:558,tracked:false,hits:0,text:"        void setSgrBit(bool setOrUnset)(AnsiSgrStyle style) pure",},{number:559,tracked:false,hits:0,text:"        {",},{number:560,tracked:false,hits:0,text:"            static if(setOrUnset)",},{number:561,tracked:true,hits:37,text:"                this._sgrBitmask |= this.sgrToBit(style);",},{number:562,tracked:false,hits:0,text:"            else",},{number:563,tracked:true,hits:0,text:"                this._sgrBitmask &= ~this.sgrToBit(style);",},{number:564,tracked:false,hits:0,text:"        }",},{number:565,tracked:false,hits:0,text:"",},{number:566,tracked:false,hits:0,text:"        @safe @nogc nothrow",},{number:567,tracked:false,hits:0,text:"        bool getSgrBit(AnsiSgrStyle style) pure const",},{number:568,tracked:false,hits:0,text:"        {",},{number:569,tracked:true,hits:126,text:"            return (this._sgrBitmask & this.sgrToBit(style)) > 0;",},{number:570,tracked:false,hits:0,text:"        }",},{number:571,tracked:false,hits:0,text:"    }",},{number:572,tracked:false,hits:0,text:"",},{number:573,tracked:false,hits:0,text:"    // Seperate functions for better documentation generation.",},{number:574,tracked:false,hits:0,text:"    //",},{number:575,tracked:false,hits:0,text:"    // Tedious, as this otherwise could've all been auto-generated.",},{number:576,tracked:false,hits:0,text:"    /+++ SETTERS +++/",},{number:577,tracked:false,hits:0,text:"    @safe @nogc nothrow pure",},{number:578,tracked:false,hits:0,text:"    {",},{number:579,tracked:false,hits:0,text:"        /// Removes all styling from this `AnsiStyle`.",},{number:580,tracked:false,hits:0,text:"        AnsiStyle reset() return",},{number:581,tracked:false,hits:0,text:"        {",},{number:582,tracked:true,hits:0,text:"            this._sgrBitmask = 0;",},{number:583,tracked:true,hits:0,text:"            return this;",},{number:584,tracked:false,hits:0,text:"        }",},{number:585,tracked:false,hits:0,text:"",},{number:586,tracked:false,hits:0,text:"        /++",},{number:587,tracked:false,hits:0,text:"         + Enables/Disables a certain styling option.",},{number:588,tracked:false,hits:0,text:"         +",},{number:589,tracked:false,hits:0,text:"         + Params:",},{number:590,tracked:false,hits:0,text:"         +  style  = The styling option to enable/disable.",},{number:591,tracked:false,hits:0,text:"         +  enable = If true, enable the option. If false, disable it.",},{number:592,tracked:false,hits:0,text:"         +",},{number:593,tracked:false,hits:0,text:"         + Returns:",},{number:594,tracked:false,hits:0,text:"         +  `this` for chaining.",},{number:595,tracked:false,hits:0,text:"         + ++/",},{number:596,tracked:false,hits:0,text:"        AnsiStyle set(AnsiSgrStyle style, bool enable) return",},{number:597,tracked:false,hits:0,text:"        {",},{number:598,tracked:true,hits:20,text:"            if(enable)",},{number:599,tracked:true,hits:20,text:"                this.setSgrBit!true(style);",},{number:600,tracked:false,hits:0,text:"            else",},{number:601,tracked:true,hits:0,text:"                this.setSgrBit!false(style);",},{number:602,tracked:true,hits:20,text:"            return this;",},{number:603,tracked:false,hits:0,text:"        }",},{number:604,tracked:false,hits:0,text:"",},{number:605,tracked:false,hits:0,text:"        ///",},{number:606,tracked:true,hits:14,text:"        AnsiStyle bold(bool enable = true) return { this.setSgrBit!true(AnsiSgrStyle.bold); return this; }",},{number:607,tracked:false,hits:0,text:"        ///",},{number:608,tracked:true,hits:2,text:"        AnsiStyle dim(bool enable = true) return { this.setSgrBit!true(AnsiSgrStyle.dim); return this; }",},{number:609,tracked:false,hits:0,text:"        ///",},{number:610,tracked:true,hits:4,text:"        AnsiStyle italic(bool enable = true) return { this.setSgrBit!true(AnsiSgrStyle.italic); return this; }",},{number:611,tracked:false,hits:0,text:"        ///",},{number:612,tracked:true,hits:12,text:"        AnsiStyle underline(bool enable = true) return { this.setSgrBit!true(AnsiSgrStyle.underline); return this; }",},{number:613,tracked:false,hits:0,text:"        ///",},{number:614,tracked:true,hits:2,text:"        AnsiStyle slowBlink(bool enable = true) return { this.setSgrBit!true(AnsiSgrStyle.slowBlink); return this; }",},{number:615,tracked:false,hits:0,text:"        ///",},{number:616,tracked:true,hits:0,text:"        AnsiStyle fastBlink(bool enable = true) return { this.setSgrBit!true(AnsiSgrStyle.fastBlink); return this; }",},{number:617,tracked:false,hits:0,text:"        ///",},{number:618,tracked:true,hits:0,text:"        AnsiStyle invert(bool enable = true) return { this.setSgrBit!true(AnsiSgrStyle.invert); return this; }",},{number:619,tracked:false,hits:0,text:"        ///",},{number:620,tracked:true,hits:0,text:"        AnsiStyle strike(bool enable = true) return { this.setSgrBit!true(AnsiSgrStyle.strike); return this; }",},{number:621,tracked:false,hits:0,text:"    }",},{number:622,tracked:false,hits:0,text:"",},{number:623,tracked:false,hits:0,text:"    /+++ GETTERS +++/",},{number:624,tracked:false,hits:0,text:"    @safe @nogc nothrow pure const",},{number:625,tracked:false,hits:0,text:"    {",},{number:626,tracked:false,hits:0,text:"        /++",},{number:627,tracked:false,hits:0,text:"         + Get the status of a certain styling option.",},{number:628,tracked:false,hits:0,text:"         +",},{number:629,tracked:false,hits:0,text:"         + Params:",},{number:630,tracked:false,hits:0,text:"         +  style = The styling option to get.",},{number:631,tracked:false,hits:0,text:"         +",},{number:632,tracked:false,hits:0,text:"         + Returns:",},{number:633,tracked:false,hits:0,text:"         +  `true` if the styling option is enabled, `false` otherwise.",},{number:634,tracked:false,hits:0,text:"         + ++/",},{number:635,tracked:false,hits:0,text:"        bool get(AnsiSgrStyle style)",},{number:636,tracked:false,hits:0,text:"        {",},{number:637,tracked:true,hits:0,text:"            return this.getSgrBit(style);",},{number:638,tracked:false,hits:0,text:"        }",},{number:639,tracked:false,hits:0,text:"        ",},{number:640,tracked:false,hits:0,text:"        ///",},{number:641,tracked:true,hits:0,text:"        bool bold() { return this.getSgrBit(AnsiSgrStyle.bold); }",},{number:642,tracked:false,hits:0,text:"        ///",},{number:643,tracked:true,hits:0,text:"        bool dim() { return this.getSgrBit(AnsiSgrStyle.dim); }",},{number:644,tracked:false,hits:0,text:"        ///",},{number:645,tracked:true,hits:0,text:"        bool italic() { return this.getSgrBit(AnsiSgrStyle.italic); }",},{number:646,tracked:false,hits:0,text:"        ///",},{number:647,tracked:true,hits:0,text:"        bool underline() { return this.getSgrBit(AnsiSgrStyle.underline); }",},{number:648,tracked:false,hits:0,text:"        ///",},{number:649,tracked:true,hits:0,text:"        bool slowBlink() { return this.getSgrBit(AnsiSgrStyle.slowBlink); }",},{number:650,tracked:false,hits:0,text:"        ///",},{number:651,tracked:true,hits:0,text:"        bool fastBlink() { return this.getSgrBit(AnsiSgrStyle.fastBlink); }",},{number:652,tracked:false,hits:0,text:"        ///",},{number:653,tracked:true,hits:0,text:"        bool invert() { return this.getSgrBit(AnsiSgrStyle.invert); }",},{number:654,tracked:false,hits:0,text:"        ///",},{number:655,tracked:true,hits:0,text:"        bool strike() { return this.getSgrBit(AnsiSgrStyle.strike); }",},{number:656,tracked:false,hits:0,text:"    }",},{number:657,tracked:false,hits:0,text:"",},{number:658,tracked:false,hits:0,text:"    /+++ OUTPUT +++/",},{number:659,tracked:false,hits:0,text:"",},{number:660,tracked:false,hits:0,text:"    static if(!BetterC)",},{number:661,tracked:false,hits:0,text:"    {",},{number:662,tracked:false,hits:0,text:"        /++",},{number:663,tracked:false,hits:0,text:"         + [Not enabled in -betterC] Converts this `AnsiStyle` into a GC-allocated sequence string.",},{number:664,tracked:false,hits:0,text:"         +",},{number:665,tracked:false,hits:0,text:"         + See_Also:",},{number:666,tracked:false,hits:0,text:"         +  `toSequence`",},{number:667,tracked:false,hits:0,text:"         + ++/",},{number:668,tracked:false,hits:0,text:"        @trusted nothrow",},{number:669,tracked:false,hits:0,text:"        string toString() const",},{number:670,tracked:false,hits:0,text:"        {",},{number:671,tracked:false,hits:0,text:"            import std.exception : assumeUnique;",},{number:672,tracked:false,hits:0,text:"",},{number:673,tracked:true,hits:0,text:"            auto chars = new char[MAX_CHARS_NEEDED];",},{number:674,tracked:true,hits:0,text:"            return this.toSequence(chars[0..MAX_CHARS_NEEDED]).assumeUnique;",},{number:675,tracked:false,hits:0,text:"        }",},{number:676,tracked:false,hits:0,text:"    }",},{number:677,tracked:false,hits:0,text:"",},{number:678,tracked:false,hits:0,text:"    /++",},{number:679,tracked:false,hits:0,text:"     + Creates an ANSI SGR command that enables all of the desired styling options, while leaving all of the other options unchanged.",},{number:680,tracked:false,hits:0,text:"     +",},{number:681,tracked:false,hits:0,text:"     + Please note that the CSI (`ANSI_CSI`/`\\033[`) and the SGR marker (`ANSI_COLOUR_END`/`m`) are not included",},{number:682,tracked:false,hits:0,text:"     + in this output.",},{number:683,tracked:false,hits:0,text:"     +",},{number:684,tracked:false,hits:0,text:"     + Notes:",},{number:685,tracked:false,hits:0,text:"     +  Any characters inside of `buffer` that are not covered by the returned slice, are left unmodified.",},{number:686,tracked:false,hits:0,text:"     +",},{number:687,tracked:false,hits:0,text:"     +  If this colour hasn't been initialised or assigned a value, then the returned value is simply `null`.",},{number:688,tracked:false,hits:0,text:"     +",},{number:689,tracked:false,hits:0,text:"     + Params:",},{number:690,tracked:false,hits:0,text:"     +  buffer = The statically allocated buffer used to store the result of this function.",},{number:691,tracked:false,hits:0,text:"     +",},{number:692,tracked:false,hits:0,text:"     + Returns:",},{number:693,tracked:false,hits:0,text:"     +  A slice into `buffer` that contains the output of this function.",},{number:694,tracked:false,hits:0,text:"     + ++/",},{number:695,tracked:false,hits:0,text:"    @safe @nogc",},{number:696,tracked:false,hits:0,text:"    char[] toSequence(ref return char[MAX_CHARS_NEEDED] buffer) nothrow const",},{number:697,tracked:false,hits:0,text:"    {",},{number:698,tracked:false,hits:0,text:"        import std.traits : EnumMembers;",},{number:699,tracked:false,hits:0,text:"",},{number:700,tracked:true,hits:33,text:"        if(this._sgrBitmask == 0)",},{number:701,tracked:true,hits:19,text:"            return null;",},{number:702,tracked:false,hits:0,text:"",},{number:703,tracked:true,hits:14,text:"        size_t cursor;",},{number:704,tracked:false,hits:0,text:"        void numIntoBuffer(uint num)",},{number:705,tracked:false,hits:0,text:"        {",},{number:706,tracked:true,hits:23,text:"            char[10] text;",},{number:707,tracked:true,hits:23,text:"            const slice = numToStrBase10(text[0..$], num);",},{number:708,tracked:true,hits:23,text:"            buffer[cursor..cursor + slice.length] = slice[];",},{number:709,tracked:true,hits:23,text:"            cursor += slice.length;",},{number:710,tracked:false,hits:0,text:"        }",},{number:711,tracked:false,hits:0,text:"",},{number:712,tracked:true,hits:14,text:"        bool isFirstValue = true;",},{number:713,tracked:false,hits:0,text:"        static foreach(flag; EnumMembers!AnsiSgrStyle)",},{number:714,tracked:false,hits:0,text:"        {{",},{number:715,tracked:true,hits:126,text:"            if(this.getSgrBit(flag))",},{number:716,tracked:false,hits:0,text:"            {",},{number:717,tracked:true,hits:23,text:"                if(!isFirstValue)",},{number:718,tracked:true,hits:9,text:"                    buffer[cursor++] = ANSI_SEPARATOR;",},{number:719,tracked:true,hits:23,text:"                isFirstValue = false;",},{number:720,tracked:false,hits:0,text:"",},{number:721,tracked:true,hits:23,text:"                numIntoBuffer(cast(uint)flag);",},{number:722,tracked:false,hits:0,text:"            }",},{number:723,tracked:false,hits:0,text:"        }}",},{number:724,tracked:false,hits:0,text:"",},{number:725,tracked:true,hits:14,text:"        return buffer[0..cursor];",},{number:726,tracked:false,hits:0,text:"    }",},{number:727,tracked:false,hits:0,text:"    ///",},{number:728,tracked:false,hits:0,text:"    @(\"AnsiStyle.toSequence(char[])\")",},{number:729,tracked:false,hits:0,text:"    unittest",},{number:730,tracked:false,hits:0,text:"    {",},{number:731,tracked:false,hits:0,text:"        static if(!BetterC)",},{number:732,tracked:false,hits:0,text:"        {",},{number:733,tracked:true,hits:1,text:"            char[AnsiStyle.MAX_CHARS_NEEDED] buffer;",},{number:734,tracked:false,hits:0,text:"            ",},{number:735,tracked:false,hits:0,text:"            void test(string expected, AnsiStyle style)",},{number:736,tracked:false,hits:0,text:"            {",},{number:737,tracked:true,hits:2,text:"                const slice = style.toSequence(buffer);",},{number:738,tracked:true,hits:2,text:"                assert(slice == expected, \"Got '\"~slice~\"' wanted '\"~expected~\"'\");",},{number:739,tracked:false,hits:0,text:"            }",},{number:740,tracked:false,hits:0,text:"",},{number:741,tracked:true,hits:1,text:"            test(\"\", AnsiStyle.init);",},{number:742,tracked:true,hits:1,text:"            test(\"1;2;3\", AnsiStyle.init.bold.dim.italic);",},{number:743,tracked:false,hits:0,text:"        }",},{number:744,tracked:false,hits:0,text:"    }",},{number:745,tracked:false,hits:0,text:"}",},{number:746,tracked:false,hits:0,text:"",},{number:747,tracked:false,hits:0,text:"/+++ DATA WITH COLOUR TYPES +++/",},{number:748,tracked:false,hits:0,text:"",},{number:749,tracked:false,hits:0,text:"/++",},{number:750,tracked:false,hits:0,text:" + Contains an `AnsiColour` for the foreground, an `AnsiColour` for the background, and an `AnsiStyle` for additional styling,",},{number:751,tracked:false,hits:0,text:" + and provides the ability to create an ANSI SGR command to set the foreground, background, and overall styling of the terminal.",},{number:752,tracked:false,hits:0,text:" +",},{number:753,tracked:false,hits:0,text:" + A.k.a This is just a container over two `AnsiColour`s and an `AnsiStyle`.",},{number:754,tracked:false,hits:0,text:" + ++/",},{number:755,tracked:false,hits:0,text:"@safe",},{number:756,tracked:false,hits:0,text:"struct AnsiStyleSet",},{number:757,tracked:false,hits:0,text:"{",},{number:758,tracked:false,hits:0,text:"    /++",},{number:759,tracked:false,hits:0,text:"     + The maximum amount of characters any singular `AnsiStyle` sequence may use.",},{number:760,tracked:false,hits:0,text:"     +",},{number:761,tracked:false,hits:0,text:"     + This is often used to create a static array to temporarily, and without allocation, store the sequence for an `AnsiStyle`.",},{number:762,tracked:false,hits:0,text:"     + ++/",},{number:763,tracked:false,hits:0,text:"    enum MAX_CHARS_NEEDED = (AnsiColour.MAX_CHARS_NEEDED * 2) + AnsiStyle.MAX_CHARS_NEEDED;",},{number:764,tracked:false,hits:0,text:"",},{number:765,tracked:false,hits:0,text:"    private AnsiColour _fg;",},{number:766,tracked:false,hits:0,text:"    private AnsiColour _bg;",},{number:767,tracked:false,hits:0,text:"    private AnsiStyle _style;",},{number:768,tracked:false,hits:0,text:"",},{number:769,tracked:false,hits:0,text:"    // As usual, functions are manually made for better documentation.",},{number:770,tracked:false,hits:0,text:"",},{number:771,tracked:false,hits:0,text:"    /+++ SETTERS +++/",},{number:772,tracked:false,hits:0,text:"    @safe @nogc nothrow",},{number:773,tracked:false,hits:0,text:"    {",},{number:774,tracked:false,hits:0,text:"        ///",},{number:775,tracked:true,hits:75,text:"        AnsiStyleSet fg(AnsiColour colour) return { this._fg = colour; this._fg.isBg = IsBgColour.no; return this; }",},{number:776,tracked:false,hits:0,text:"        ///",},{number:777,tracked:true,hits:7,text:"        AnsiStyleSet fg(Ansi4BitColour colour) return { return this.fg(AnsiColour(colour)); }",},{number:778,tracked:false,hits:0,text:"        ///",},{number:779,tracked:true,hits:4,text:"        AnsiStyleSet fg(Ansi8BitColour colour) return { return this.fg(AnsiColour(colour)); }",},{number:780,tracked:false,hits:0,text:"        ///",},{number:781,tracked:true,hits:4,text:"        AnsiStyleSet fg(AnsiRgbColour colour) return { return this.fg(AnsiColour(colour)); }",},{number:782,tracked:false,hits:0,text:"",},{number:783,tracked:false,hits:0,text:"        ///",},{number:784,tracked:true,hits:75,text:"        AnsiStyleSet bg(AnsiColour colour) return { this._bg = colour; this._bg.isBg = IsBgColour.yes; return this; }",},{number:785,tracked:false,hits:0,text:"        ///",},{number:786,tracked:true,hits:6,text:"        AnsiStyleSet bg(Ansi4BitColour colour) return { return this.bg(AnsiColour(colour)); }",},{number:787,tracked:false,hits:0,text:"        ///",},{number:788,tracked:true,hits:4,text:"        AnsiStyleSet bg(Ansi8BitColour colour) return { return this.bg(AnsiColour(colour)); }",},{number:789,tracked:false,hits:0,text:"        ///",},{number:790,tracked:true,hits:5,text:"        AnsiStyleSet bg(AnsiRgbColour colour) return { return this.bg(AnsiColour(colour)); }",},{number:791,tracked:false,hits:0,text:"        ///",},{number:792,tracked:false,hits:0,text:"",},{number:793,tracked:false,hits:0,text:"        ///",},{number:794,tracked:true,hits:64,text:"        AnsiStyleSet style(AnsiStyle style) return { this._style = style; return this; }",},{number:795,tracked:false,hits:0,text:"    }",},{number:796,tracked:false,hits:0,text:"",},{number:797,tracked:false,hits:0,text:"    /+++ GETTERS +++/",},{number:798,tracked:false,hits:0,text:"    @safe @nogc nothrow const",},{number:799,tracked:false,hits:0,text:"    {",},{number:800,tracked:false,hits:0,text:"        ///",},{number:801,tracked:true,hits:1,text:"        AnsiColour fg() { return this._fg; }",},{number:802,tracked:false,hits:0,text:"        ///",},{number:803,tracked:true,hits:1,text:"        AnsiColour bg() { return this._bg; }",},{number:804,tracked:false,hits:0,text:"        ///",},{number:805,tracked:true,hits:43,text:"        AnsiStyle style() { return this._style; }",},{number:806,tracked:false,hits:0,text:"    }",},{number:807,tracked:false,hits:0,text:"",},{number:808,tracked:false,hits:0,text:"    /+++ OUTPUT ++/",},{number:809,tracked:false,hits:0,text:"    /++",},{number:810,tracked:false,hits:0,text:"     + Creates an ANSI SGR command that sets the foreground colour, sets the background colour,",},{number:811,tracked:false,hits:0,text:"     + and enables all of the desired styling options, while leaving all of the other options unchanged.",},{number:812,tracked:false,hits:0,text:"     +",},{number:813,tracked:false,hits:0,text:"     + Please note that the CSI (`ANSI_CSI`/`\\033[`) and the SGR marker (`ANSI_COLOUR_END`/`m`) are not included",},{number:814,tracked:false,hits:0,text:"     + in this output.",},{number:815,tracked:false,hits:0,text:"     +",},{number:816,tracked:false,hits:0,text:"     + Notes:",},{number:817,tracked:false,hits:0,text:"     +  Any characters inside of `buffer` that are not covered by the returned slice, are left unmodified.",},{number:818,tracked:false,hits:0,text:"     +",},{number:819,tracked:false,hits:0,text:"     +  If this colour hasn't been initialised or assigned a value, then the returned value is simply `null`.",},{number:820,tracked:false,hits:0,text:"     +",},{number:821,tracked:false,hits:0,text:"     + Params:",},{number:822,tracked:false,hits:0,text:"     +  buffer = The statically allocated buffer used to store the result of this function.",},{number:823,tracked:false,hits:0,text:"     +",},{number:824,tracked:false,hits:0,text:"     + Returns:",},{number:825,tracked:false,hits:0,text:"     +  A slice into `buffer` that contains the output of this function.",},{number:826,tracked:false,hits:0,text:"     + ++/",},{number:827,tracked:false,hits:0,text:"    @safe @nogc",},{number:828,tracked:false,hits:0,text:"    char[] toSequence(ref return char[MAX_CHARS_NEEDED] buffer) nothrow const",},{number:829,tracked:false,hits:0,text:"    {",},{number:830,tracked:true,hits:31,text:"        size_t cursor;",},{number:831,tracked:false,hits:0,text:"",},{number:832,tracked:true,hits:31,text:"        char[AnsiColour.MAX_CHARS_NEEDED] colour;",},{number:833,tracked:true,hits:31,text:"        char[AnsiStyle.MAX_CHARS_NEEDED] style;",},{number:834,tracked:false,hits:0,text:"",},{number:835,tracked:true,hits:31,text:"        auto slice = this._fg.toSequence(colour);",},{number:836,tracked:true,hits:31,text:"        buffer[cursor..cursor + slice.length] = slice[];",},{number:837,tracked:true,hits:31,text:"        cursor += slice.length;",},{number:838,tracked:false,hits:0,text:"",},{number:839,tracked:true,hits:31,text:"        slice = this._bg.toSequence(colour);",},{number:840,tracked:true,hits:42,text:"        if(slice.length > 0 && cursor > 0)",},{number:841,tracked:true,hits:7,text:"            buffer[cursor++] = ANSI_SEPARATOR;",},{number:842,tracked:true,hits:31,text:"        buffer[cursor..cursor + slice.length] = slice[];",},{number:843,tracked:true,hits:31,text:"        cursor += slice.length;",},{number:844,tracked:false,hits:0,text:"",},{number:845,tracked:true,hits:31,text:"        slice = this.style.toSequence(style);",},{number:846,tracked:true,hits:44,text:"        if(slice.length > 0 && cursor > 0)",},{number:847,tracked:true,hits:4,text:"            buffer[cursor++] = ANSI_SEPARATOR;",},{number:848,tracked:true,hits:31,text:"        buffer[cursor..cursor + slice.length] = slice[];",},{number:849,tracked:true,hits:31,text:"        cursor += slice.length;",},{number:850,tracked:false,hits:0,text:"",},{number:851,tracked:true,hits:31,text:"        return buffer[0..cursor];",},{number:852,tracked:false,hits:0,text:"    }",},{number:853,tracked:false,hits:0,text:"    ///",},{number:854,tracked:false,hits:0,text:"    @(\"AnsiStyleSet.toSequence\")",},{number:855,tracked:false,hits:0,text:"    unittest",},{number:856,tracked:false,hits:0,text:"    {",},{number:857,tracked:true,hits:1,text:"        char[AnsiStyleSet.MAX_CHARS_NEEDED] buffer;",},{number:858,tracked:false,hits:0,text:"",},{number:859,tracked:false,hits:0,text:"        void test(string expected, AnsiStyleSet ch)",},{number:860,tracked:false,hits:0,text:"        {",},{number:861,tracked:true,hits:2,text:"            auto slice = ch.toSequence(buffer);",},{number:862,tracked:true,hits:2,text:"            assert(slice == expected, \"Got '\"~slice~\"' expected '\"~expected~\"'\");",},{number:863,tracked:false,hits:0,text:"        }",},{number:864,tracked:false,hits:0,text:"",},{number:865,tracked:true,hits:1,text:"        test(\"\", AnsiStyleSet.init);",},{number:866,tracked:true,hits:1,text:"        test(",},{number:867,tracked:false,hits:0,text:"            \"32;48;2;255;128;64;1;4\", ",},{number:868,tracked:false,hits:0,text:"            AnsiStyleSet.init",},{number:869,tracked:false,hits:0,text:"                    .fg(Ansi4BitColour.green)",},{number:870,tracked:false,hits:0,text:"                    .bg(AnsiRgbColour(255, 128, 64))",},{number:871,tracked:false,hits:0,text:"                    .style(AnsiStyle.init.bold.underline)",},{number:872,tracked:false,hits:0,text:"        );",},{number:873,tracked:false,hits:0,text:"    }",},{number:874,tracked:false,hits:0,text:"}",},{number:875,tracked:false,hits:0,text:"",},{number:876,tracked:false,hits:0,text:"/++",},{number:877,tracked:false,hits:0,text:" + An enumeration used by an `AnsiText` implementation to describe any special features that `AnsiText` needs to mold",},{number:878,tracked:false,hits:0,text:" + itself around.",},{number:879,tracked:false,hits:0,text:" + ++/",},{number:880,tracked:false,hits:0,text:"enum AnsiTextImplementationFeatures",},{number:881,tracked:false,hits:0,text:"{",},{number:882,tracked:false,hits:0,text:"    /// Supports at least `.put`, `.toSink`, `char[] .newSlice`, and allows `AnsiText` to handle the encoding.",},{number:883,tracked:false,hits:0,text:"    basic = 0, ",},{number:884,tracked:false,hits:0,text:"}",},{number:885,tracked:false,hits:0,text:"",},{number:886,tracked:false,hits:0,text:"/++",},{number:887,tracked:false,hits:0,text:" + A lightweight alternative to `AnsiText` which only supports a singular coloured string, at the cost",},{number:888,tracked:false,hits:0,text:" + of removing most of the other complexity & dynamic allocation needs of `AnsiText`.",},{number:889,tracked:false,hits:0,text:" +",},{number:890,tracked:false,hits:0,text:" + If you only need to style your string in one certain way, or want to avoid `AnsiText` altogether, then this struct",},{number:891,tracked:false,hits:0,text:" + is the way to go.",},{number:892,tracked:false,hits:0,text:" +",},{number:893,tracked:false,hits:0,text:" + Usage_(Manually):",},{number:894,tracked:false,hits:0,text:" +  First, retrieve and the ANSI styling sequence via `AnsiTextLite.toFullStartSequence` and output it.",},{number:895,tracked:false,hits:0,text:" +",},{number:896,tracked:false,hits:0,text:" +  Second, output `AnsiTextLite.text`.",},{number:897,tracked:false,hits:0,text:" +",},{number:898,tracked:false,hits:0,text:" +  Finally, and optionally, retrieve the ANSI reset sequence via `AnsiTextLite.toFullEndSequence` and output it.",},{number:899,tracked:false,hits:0,text:" +",},{number:900,tracked:false,hits:0,text:" + Usage_(Range):",},{number:901,tracked:false,hits:0,text:" +  Call `AnsiTextLite.toRange` to get the range, please read its documentation as it is important (it'll return slices to stack-allocated memory).",},{number:902,tracked:false,hits:0,text:" +",},{number:903,tracked:false,hits:0,text:" + Usage_(GC):",},{number:904,tracked:false,hits:0,text:" +  If you're not compiling under `-betterc`, then `AnsiTextLite.toString()` will provide you with a GC-allocated string containing:",},{number:905,tracked:false,hits:0,text:" +  the start ANSI sequence; the text to display; and the end ANSI sequence. i.e. A string that is just ready to be printed.",},{number:906,tracked:false,hits:0,text:" +",},{number:907,tracked:false,hits:0,text:" +  This struct also implements the sink-based version of `toString`, which means that when used directly with things like `writeln`, this struct",},{number:908,tracked:false,hits:0,text:" +  is able to avoid allocations (unless the sink itself allocates). See the unittest for an example.",},{number:909,tracked:false,hits:0,text:" +",},{number:910,tracked:false,hits:0,text:" + See_Also:",},{number:911,tracked:false,hits:0,text:" +  `ansi` for fluent creation of an `AnsiTextLite`.",},{number:912,tracked:false,hits:0,text:" +",},{number:913,tracked:false,hits:0,text:" +  This struct's unittest for an example of usage.",},{number:914,tracked:false,hits:0,text:" + ++/",},{number:915,tracked:false,hits:0,text:"struct AnsiTextLite",},{number:916,tracked:false,hits:0,text:"{",},{number:917,tracked:false,hits:0,text:"    /++",},{number:918,tracked:false,hits:0,text:"     + The maximum amount of chars required by the start sequence of an `AnsiTextLite` (`toFullStartSequence`).",},{number:919,tracked:false,hits:0,text:"     + ++/",},{number:920,tracked:false,hits:0,text:"    enum MAX_CHARS_NEEDED = AnsiStyleSet.MAX_CHARS_NEEDED + ANSI_CSI.length + 1; // + 1 for the ANSI_COLOUR_END",},{number:921,tracked:false,hits:0,text:"",},{number:922,tracked:false,hits:0,text:"    /// The text to output.",},{number:923,tracked:false,hits:0,text:"    const(char)[] text;",},{number:924,tracked:false,hits:0,text:"    ",},{number:925,tracked:false,hits:0,text:"    /// The styling to apply to the text.",},{number:926,tracked:false,hits:0,text:"    AnsiStyleSet styleSet;",},{number:927,tracked:false,hits:0,text:"",},{number:928,tracked:false,hits:0,text:"    /+++ SETTERS +++/",},{number:929,tracked:false,hits:0,text:"    // TODO: Should probably make a mixin template for this, but I need to see how the documentation generators handle that.",},{number:930,tracked:false,hits:0,text:"    //       I also can't just do an `alias this`, as otherwise the style functions wouldn't return `AnsiTextLite`, but instead `AnsiStyleSet`.",},{number:931,tracked:false,hits:0,text:"    //       Or just suck it up and make some of the setters templatised, much to the dismay of documentation.",},{number:932,tracked:false,hits:0,text:"    @safe @nogc nothrow",},{number:933,tracked:false,hits:0,text:"    {",},{number:934,tracked:false,hits:0,text:"        ///",},{number:935,tracked:true,hits:3,text:"        AnsiTextLite fg(AnsiColour colour) return { this.styleSet.fg = colour; this.styleSet.fg.isBg = IsBgColour.no; return this; }",},{number:936,tracked:false,hits:0,text:"        ///",},{number:937,tracked:true,hits:1,text:"        AnsiTextLite fg(Ansi4BitColour colour) return { return this.fg(AnsiColour(colour)); }",},{number:938,tracked:false,hits:0,text:"        ///",},{number:939,tracked:true,hits:0,text:"        AnsiTextLite fg(Ansi8BitColour colour) return { return this.fg(AnsiColour(colour)); }",},{number:940,tracked:false,hits:0,text:"        ///",},{number:941,tracked:true,hits:0,text:"        AnsiTextLite fg(AnsiRgbColour colour) return { return this.fg(AnsiColour(colour)); }",},{number:942,tracked:false,hits:0,text:"",},{number:943,tracked:false,hits:0,text:"        ///",},{number:944,tracked:true,hits:3,text:"        AnsiTextLite bg(AnsiColour colour) return { this.styleSet.bg = colour; this.styleSet.bg.isBg = IsBgColour.yes; return this; }",},{number:945,tracked:false,hits:0,text:"        ///",},{number:946,tracked:true,hits:0,text:"        AnsiTextLite bg(Ansi4BitColour colour) return { return this.bg(AnsiColour(colour)); }",},{number:947,tracked:false,hits:0,text:"        ///",},{number:948,tracked:true,hits:0,text:"        AnsiTextLite bg(Ansi8BitColour colour) return { return this.bg(AnsiColour(colour)); }",},{number:949,tracked:false,hits:0,text:"        ///",},{number:950,tracked:true,hits:1,text:"        AnsiTextLite bg(AnsiRgbColour colour) return { return this.bg(AnsiColour(colour)); }",},{number:951,tracked:false,hits:0,text:"        ///",},{number:952,tracked:false,hits:0,text:"",},{number:953,tracked:false,hits:0,text:"        ///",},{number:954,tracked:true,hits:2,text:"        AnsiTextLite style(AnsiStyle style) return { this.styleSet.style = style; return this; }",},{number:955,tracked:false,hits:0,text:"    }",},{number:956,tracked:false,hits:0,text:"",},{number:957,tracked:false,hits:0,text:"    /+++ GETTERS +++/",},{number:958,tracked:false,hits:0,text:"    @safe @nogc nothrow const",},{number:959,tracked:false,hits:0,text:"    {",},{number:960,tracked:false,hits:0,text:"        ///",},{number:961,tracked:true,hits:0,text:"        AnsiColour fg() { return this.styleSet.fg; }",},{number:962,tracked:false,hits:0,text:"        ///",},{number:963,tracked:true,hits:0,text:"        AnsiColour bg() { return this.styleSet.bg; }",},{number:964,tracked:false,hits:0,text:"        ///",},{number:965,tracked:true,hits:0,text:"        AnsiStyle style() { return this.styleSet.style; }",},{number:966,tracked:false,hits:0,text:"    }",},{number:967,tracked:false,hits:0,text:"",},{number:968,tracked:false,hits:0,text:"    @safe @nogc nothrow const",},{number:969,tracked:false,hits:0,text:"    {",},{number:970,tracked:false,hits:0,text:"        /++",},{number:971,tracked:false,hits:0,text:"         + Populates the given buffer with the full ANSI sequence needed to enable the styling",},{number:972,tracked:false,hits:0,text:"         + defined within this `AnsiTextLite`",},{number:973,tracked:false,hits:0,text:"         +",},{number:974,tracked:false,hits:0,text:"         + Unlike the usual `toSequence` functions, this function includes the `ANSI_CSI` and `ANSI_COLOUR_END` markers,",},{number:975,tracked:false,hits:0,text:"         + meaning the output from this function is ready to be printed as-is.",},{number:976,tracked:false,hits:0,text:"         +",},{number:977,tracked:false,hits:0,text:"         + Do note that this function doesn't insert a null-terminator, so if you're using anything based on C strings, you need",},{number:978,tracked:false,hits:0,text:"         + to insert that yourself.",},{number:979,tracked:false,hits:0,text:"         +",},{number:980,tracked:false,hits:0,text:"         + Notes:",},{number:981,tracked:false,hits:0,text:"         +  Any parts of the `buffer` that are not populated by this function are left untouched.",},{number:982,tracked:false,hits:0,text:"         +",},{number:983,tracked:false,hits:0,text:"         + Params:",},{number:984,tracked:false,hits:0,text:"         +  buffer = The buffer to populate.",},{number:985,tracked:false,hits:0,text:"         +",},{number:986,tracked:false,hits:0,text:"         + Returns:",},{number:987,tracked:false,hits:0,text:"         +  The slice of `buffer` that has been populated.",},{number:988,tracked:false,hits:0,text:"         + ++/",},{number:989,tracked:false,hits:0,text:"        char[] toFullStartSequence(ref return char[MAX_CHARS_NEEDED] buffer)",},{number:990,tracked:false,hits:0,text:"        {",},{number:991,tracked:true,hits:0,text:"            size_t cursor;",},{number:992,tracked:false,hits:0,text:"",},{number:993,tracked:true,hits:0,text:"            buffer[0..ANSI_CSI.length] = ANSI_CSI[];",},{number:994,tracked:true,hits:0,text:"            cursor += ANSI_CSI.length;",},{number:995,tracked:false,hits:0,text:"",},{number:996,tracked:true,hits:0,text:"            char[AnsiStyleSet.MAX_CHARS_NEEDED] styleBuffer;",},{number:997,tracked:true,hits:0,text:"            const styleSlice = this.styleSet.toSequence(styleBuffer);",},{number:998,tracked:true,hits:0,text:"            buffer[cursor..cursor+styleSlice.length] = styleSlice[];",},{number:999,tracked:true,hits:0,text:"            cursor += styleSlice.length;",},{number:1000,tracked:false,hits:0,text:"",},{number:1001,tracked:true,hits:0,text:"            buffer[cursor++] = ANSI_COLOUR_END;",},{number:1002,tracked:false,hits:0,text:"",},{number:1003,tracked:true,hits:0,text:"            return buffer[0..cursor];",},{number:1004,tracked:false,hits:0,text:"        }",},{number:1005,tracked:false,hits:0,text:"",},{number:1006,tracked:false,hits:0,text:"        /++",},{number:1007,tracked:false,hits:0,text:"         + Returns:",},{number:1008,tracked:false,hits:0,text:"         +  The end ANSI sequence for `AnsiTextLite`, which is simply a statically allocated version of the `ANSI_COLOUR_RESET` constant.",},{number:1009,tracked:false,hits:0,text:"         + ++/",},{number:1010,tracked:false,hits:0,text:"        char[ANSI_COLOUR_RESET.length] toFullEndSequence()",},{number:1011,tracked:false,hits:0,text:"        {",},{number:1012,tracked:true,hits:0,text:"            typeof(return) buffer;",},{number:1013,tracked:true,hits:0,text:"            buffer[0..$] = ANSI_COLOUR_RESET[];",},{number:1014,tracked:true,hits:0,text:"            return buffer;",},{number:1015,tracked:false,hits:0,text:"        }",},{number:1016,tracked:false,hits:0,text:"",},{number:1017,tracked:false,hits:0,text:"        /++",},{number:1018,tracked:false,hits:0,text:"         + Provides a range that returns, in this order: The start sequence (`.toFullStartSequence`); the output text (`.text`),",},{number:1019,tracked:false,hits:0,text:"         + and finally the end sequence (`.toFullEndSequence`).",},{number:1020,tracked:false,hits:0,text:"         +",},{number:1021,tracked:false,hits:0,text:"         + This range is $(B weakly-safe) as it $(B returns slices to stack memory) so please ensure that $(B any returned slices don't outlive the origin range object).",},{number:1022,tracked:false,hits:0,text:"         +",},{number:1023,tracked:false,hits:0,text:"         + Please also note that non of the returned slices contain null terminators.",},{number:1024,tracked:false,hits:0,text:"         +",},{number:1025,tracked:false,hits:0,text:"         + Returns:",},{number:1026,tracked:false,hits:0,text:"         +  An Input Range that returns all the slices required to correctly display this `AnsiTextLite` onto a console.",},{number:1027,tracked:false,hits:0,text:"         + ++/",},{number:1028,tracked:false,hits:0,text:"        auto toRange()",},{number:1029,tracked:false,hits:0,text:"        {",},{number:1030,tracked:false,hits:0,text:"            static struct Range",},{number:1031,tracked:false,hits:0,text:"            {",},{number:1032,tracked:false,hits:0,text:"                char[MAX_CHARS_NEEDED] start;",},{number:1033,tracked:false,hits:0,text:"                const(char)[] middle;",},{number:1034,tracked:false,hits:0,text:"                char[ANSI_COLOUR_RESET.length] end;",},{number:1035,tracked:false,hits:0,text:"                char[] startSlice;",},{number:1036,tracked:false,hits:0,text:"",},{number:1037,tracked:false,hits:0,text:"                size_t sliceCount;",},{number:1038,tracked:false,hits:0,text:"",},{number:1039,tracked:false,hits:0,text:"                @safe @nogc nothrow:",},{number:1040,tracked:false,hits:0,text:"",},{number:1041,tracked:false,hits:0,text:"                bool empty()",},{number:1042,tracked:false,hits:0,text:"                {",},{number:1043,tracked:true,hits:0,text:"                    return this.sliceCount >= 3;",},{number:1044,tracked:false,hits:0,text:"                }",},{number:1045,tracked:false,hits:0,text:"",},{number:1046,tracked:false,hits:0,text:"                void popFront()",},{number:1047,tracked:false,hits:0,text:"                {",},{number:1048,tracked:true,hits:0,text:"                    this.sliceCount++;",},{number:1049,tracked:false,hits:0,text:"                }",},{number:1050,tracked:false,hits:0,text:"",},{number:1051,tracked:false,hits:0,text:"                @trusted",},{number:1052,tracked:false,hits:0,text:"                const(char)[] front() return",},{number:1053,tracked:false,hits:0,text:"                {",},{number:1054,tracked:true,hits:0,text:"                    switch(sliceCount)",},{number:1055,tracked:false,hits:0,text:"                    {",},{number:1056,tracked:true,hits:0,text:"                        case 0: return this.startSlice;",},{number:1057,tracked:true,hits:0,text:"                        case 1: return this.middle;",},{number:1058,tracked:true,hits:0,text:"                        case 2: return this.end[0..$];",},{number:1059,tracked:false,hits:0,text:"                        default: assert(false, \"Cannot use empty range.\");",},{number:1060,tracked:false,hits:0,text:"                    }   ",},{number:1061,tracked:false,hits:0,text:"                }",},{number:1062,tracked:false,hits:0,text:"            }",},{number:1063,tracked:false,hits:0,text:"",},{number:1064,tracked:true,hits:0,text:"            Range r;",},{number:1065,tracked:true,hits:0,text:"            r.startSlice = this.toFullStartSequence(r.start);",},{number:1066,tracked:true,hits:0,text:"            r.middle = this.text;",},{number:1067,tracked:true,hits:0,text:"            r.end = this.toFullEndSequence();",},{number:1068,tracked:false,hits:0,text:"",},{number:1069,tracked:true,hits:0,text:"            return r;",},{number:1070,tracked:false,hits:0,text:"        }",},{number:1071,tracked:false,hits:0,text:"    }",},{number:1072,tracked:false,hits:0,text:"",},{number:1073,tracked:false,hits:0,text:"    static if(!BetterC)",},{number:1074,tracked:false,hits:0,text:"    /++",},{number:1075,tracked:false,hits:0,text:"     + Notes:",},{number:1076,tracked:false,hits:0,text:"     +  This struct implements the sink-based `toString` which performs no allocations, so the likes of `std.stdio.writeln` will",},{number:1077,tracked:false,hits:0,text:"     +  automatically use the sink-based version if you pass this struct to it directly.",},{number:1078,tracked:false,hits:0,text:"     +",},{number:1079,tracked:false,hits:0,text:"     + Returns: ",},{number:1080,tracked:false,hits:0,text:"     +  A GC-allocated string containing this `AnsiTextLite` as an ANSI-encoded string, ready for printing.",},{number:1081,tracked:false,hits:0,text:"     + ++/",},{number:1082,tracked:false,hits:0,text:"    @trusted nothrow // @trusted due to .assumeUnique",},{number:1083,tracked:false,hits:0,text:"    string toString() const",},{number:1084,tracked:false,hits:0,text:"    {",},{number:1085,tracked:false,hits:0,text:"        import std.exception : assumeUnique;",},{number:1086,tracked:false,hits:0,text:"",},{number:1087,tracked:true,hits:0,text:"        char[MAX_CHARS_NEEDED] styleBuffer;",},{number:1088,tracked:true,hits:0,text:"        const styleSlice = this.toFullStartSequence(styleBuffer);",},{number:1089,tracked:false,hits:0,text:"",},{number:1090,tracked:true,hits:0,text:"        auto buffer = new char[styleSlice.length + this.text.length + ANSI_COLOUR_RESET.length];",},{number:1091,tracked:true,hits:0,text:"        buffer[0..styleSlice.length]                                  = styleSlice[];",},{number:1092,tracked:true,hits:0,text:"        buffer[styleSlice.length..styleSlice.length+this.text.length] = this.text[];",},{number:1093,tracked:true,hits:0,text:"        buffer[$-ANSI_COLOUR_RESET.length..$]                         = ANSI_COLOUR_RESET[];",},{number:1094,tracked:false,hits:0,text:"",},{number:1095,tracked:true,hits:0,text:"        return buffer.assumeUnique;",},{number:1096,tracked:false,hits:0,text:"    }",},{number:1097,tracked:false,hits:0,text:"",},{number:1098,tracked:false,hits:0,text:"    /++",},{number:1099,tracked:false,hits:0,text:"     + The sink-based version of `toString`, which doesn't allocate by itself unless the `sink` decides to allocate.",},{number:1100,tracked:false,hits:0,text:"     +",},{number:1101,tracked:false,hits:0,text:"     + Params:",},{number:1102,tracked:false,hits:0,text:"     +  sink = The sink to output into.",},{number:1103,tracked:false,hits:0,text:"     +",},{number:1104,tracked:false,hits:0,text:"     + See_Also:",},{number:1105,tracked:false,hits:0,text:"     +  `toSink` for a templatised version of this function which can infer attributes, and supports any form of Output Range instead of just a delegate.",},{number:1106,tracked:false,hits:0,text:"     + ++/",},{number:1107,tracked:false,hits:0,text:"    void toString(scope void delegate(const(char)[]) sink) const",},{number:1108,tracked:false,hits:0,text:"    {",},{number:1109,tracked:true,hits:0,text:"        foreach(slice; this.toRange())",},{number:1110,tracked:true,hits:0,text:"            sink(slice);",},{number:1111,tracked:false,hits:0,text:"    }",},{number:1112,tracked:false,hits:0,text:"",},{number:1113,tracked:false,hits:0,text:"    /++",},{number:1114,tracked:false,hits:0,text:"     + Outputs in order: The start sequence (`.toFullStartSequence`), the output text (`.text`), and the end sequence (`.toFullEndSequence`)",},{number:1115,tracked:false,hits:0,text:"     + into the given `sink`.",},{number:1116,tracked:false,hits:0,text:"     +",},{number:1117,tracked:false,hits:0,text:"     + This function by itself does not allocate memory.",},{number:1118,tracked:false,hits:0,text:"     +",},{number:1119,tracked:false,hits:0,text:"     + This function will infer attributes, so as to be used in whatever attribute-souped environment your sink supports.",},{number:1120,tracked:false,hits:0,text:"     +",},{number:1121,tracked:false,hits:0,text:"     + $(B Please read the warnings described in `.toRange`) TLDR; don't persist the slices given to the sink under any circumstance. You must",},{number:1122,tracked:false,hits:0,text:"     + copy the data as soon as you get it.",},{number:1123,tracked:false,hits:0,text:"     +",},{number:1124,tracked:false,hits:0,text:"     + Params:",},{number:1125,tracked:false,hits:0,text:"     +  sink = The sink to output into.",},{number:1126,tracked:false,hits:0,text:"     + ++/",},{number:1127,tracked:false,hits:0,text:"    void toSink(Sink)(scope ref Sink sink) const",},{number:1128,tracked:false,hits:0,text:"    {",},{number:1129,tracked:false,hits:0,text:"        foreach(slice; this.toRange())",},{number:1130,tracked:false,hits:0,text:"            sink.put(slice);",},{number:1131,tracked:false,hits:0,text:"    }",},{number:1132,tracked:false,hits:0,text:"}",},{number:1133,tracked:false,hits:0,text:"///",},{number:1134,tracked:false,hits:0,text:"@(\"AnsiTextLite\")",},{number:1135,tracked:false,hits:0,text:"unittest",},{number:1136,tracked:false,hits:0,text:"{",},{number:1137,tracked:false,hits:0,text:"    static if(!BetterC)",},{number:1138,tracked:false,hits:0,text:"    {",},{number:1139,tracked:true,hits:1,text:"        auto text = \"Hello!\".ansi",},{number:1140,tracked:false,hits:0,text:"                            .fg(Ansi4BitColour.green)",},{number:1141,tracked:false,hits:0,text:"                            .bg(AnsiRgbColour(128, 128, 128))",},{number:1142,tracked:false,hits:0,text:"                            .style(AnsiStyle.init.bold.underline);",},{number:1143,tracked:false,hits:0,text:"",},{number:1144,tracked:false,hits:0,text:"        // Usage 1: Manually",},{number:1145,tracked:false,hits:0,text:"        import core.stdc.stdio : printf;",},{number:1146,tracked:false,hits:0,text:"        import std.stdio : writeln, write;",},{number:1147,tracked:false,hits:0,text:"        version(JANSI_TestOutput) // Just so test output isn't clogged. This still shows you how to use things though.",},{number:1148,tracked:false,hits:0,text:"        {",},{number:1149,tracked:false,hits:0,text:"            char[AnsiTextLite.MAX_CHARS_NEEDED + 1] startSequence; // + 1 for null terminator.",},{number:1150,tracked:false,hits:0,text:"            const sliceFromStartSequence = text.toFullStartSequence(startSequence[0..AnsiTextLite.MAX_CHARS_NEEDED]);",},{number:1151,tracked:false,hits:0,text:"            startSequence[sliceFromStartSequence.length] = '\\0';",},{number:1152,tracked:false,hits:0,text:"",},{number:1153,tracked:false,hits:0,text:"            char[200] textBuffer;",},{number:1154,tracked:false,hits:0,text:"            textBuffer[0..text.text.length] = text.text[];",},{number:1155,tracked:false,hits:0,text:"            textBuffer[text.text.length] = '\\0';",},{number:1156,tracked:false,hits:0,text:"",},{number:1157,tracked:false,hits:0,text:"            char[ANSI_COLOUR_RESET.length + 1] endSequence;",},{number:1158,tracked:false,hits:0,text:"            endSequence[0..ANSI_COLOUR_RESET.length] = text.toFullEndSequence()[];",},{number:1159,tracked:false,hits:0,text:"            endSequence[$-1] = '\\0';",},{number:1160,tracked:false,hits:0,text:"",},{number:1161,tracked:false,hits:0,text:"            printf(\"%s%s%s\\n\", startSequence.ptr, textBuffer.ptr, endSequence.ptr);",},{number:1162,tracked:false,hits:0,text:"        }",},{number:1163,tracked:false,hits:0,text:"",},{number:1164,tracked:false,hits:0,text:"        // Usage 2: Range (RETURNS STACK MEMORY, DO NOT ALLOW SLICES TO OUTLIVE RANGE OBJECT WITHOUT EXPLICIT COPY)",},{number:1165,tracked:false,hits:0,text:"        version(JANSI_TestOutput)",},{number:1166,tracked:false,hits:0,text:"        {",},{number:1167,tracked:false,hits:0,text:"            // -betterC",},{number:1168,tracked:false,hits:0,text:"            foreach(slice; text.toRange)",},{number:1169,tracked:false,hits:0,text:"            {",},{number:1170,tracked:false,hits:0,text:"                char[200] buffer;",},{number:1171,tracked:false,hits:0,text:"                buffer[0..slice.length] = slice[];",},{number:1172,tracked:false,hits:0,text:"                buffer[slice.length] = '\\0';",},{number:1173,tracked:false,hits:0,text:"                printf(\"%s\", buffer.ptr);",},{number:1174,tracked:false,hits:0,text:"            }",},{number:1175,tracked:false,hits:0,text:"            printf(\"\\n\");",},{number:1176,tracked:false,hits:0,text:"",},{number:1177,tracked:false,hits:0,text:"            // GC",},{number:1178,tracked:false,hits:0,text:"            foreach(slice; text.toRange)",},{number:1179,tracked:false,hits:0,text:"                write(slice);",},{number:1180,tracked:false,hits:0,text:"            writeln();",},{number:1181,tracked:false,hits:0,text:"        }",},{number:1182,tracked:false,hits:0,text:"        ",},{number:1183,tracked:false,hits:0,text:"        // Usage 3: toString (Sink-based, so AnsiTextLite doesn't allocate, but writeln/the sink might)",},{number:1184,tracked:false,hits:0,text:"        version(JANSI_TestOutput)",},{number:1185,tracked:false,hits:0,text:"        {",},{number:1186,tracked:false,hits:0,text:"            writeln(text); // Calls the sink-based .toString();",},{number:1187,tracked:false,hits:0,text:"        }",},{number:1188,tracked:false,hits:0,text:"",},{number:1189,tracked:false,hits:0,text:"        // Usage 4: toString (non-sink, non-betterc only)",},{number:1190,tracked:false,hits:0,text:"        version(JANSI_TestOutput)",},{number:1191,tracked:false,hits:0,text:"        {",},{number:1192,tracked:false,hits:0,text:"            writeln(text.toString());",},{number:1193,tracked:false,hits:0,text:"        }",},{number:1194,tracked:false,hits:0,text:"",},{number:1195,tracked:false,hits:0,text:"        // Usage 5: toSink",},{number:1196,tracked:false,hits:0,text:"        version(JANSI_TestOutput)",},{number:1197,tracked:false,hits:0,text:"        {",},{number:1198,tracked:false,hits:0,text:"            struct CustomOutputRange",},{number:1199,tracked:false,hits:0,text:"            {",},{number:1200,tracked:false,hits:0,text:"                char[] output;",},{number:1201,tracked:false,hits:0,text:"                @safe",},{number:1202,tracked:false,hits:0,text:"                void put(const(char)[] slice) nothrow",},{number:1203,tracked:false,hits:0,text:"                {",},{number:1204,tracked:false,hits:0,text:"                    const start = output.length;",},{number:1205,tracked:false,hits:0,text:"                    output.length += slice.length;",},{number:1206,tracked:false,hits:0,text:"                    output[start..$] = slice[];",},{number:1207,tracked:false,hits:0,text:"                }",},{number:1208,tracked:false,hits:0,text:"            }",},{number:1209,tracked:false,hits:0,text:"",},{number:1210,tracked:false,hits:0,text:"            CustomOutputRange sink;",},{number:1211,tracked:false,hits:0,text:"            ()@safe nothrow{ text.toSink(sink); }();",},{number:1212,tracked:false,hits:0,text:"            ",},{number:1213,tracked:false,hits:0,text:"            writeln(sink.output);",},{number:1214,tracked:false,hits:0,text:"        }",},{number:1215,tracked:false,hits:0,text:"    }",},{number:1216,tracked:false,hits:0,text:"}",},{number:1217,tracked:false,hits:0,text:"",},{number:1218,tracked:false,hits:0,text:"/++",},{number:1219,tracked:false,hits:0,text:" + Contains a string that supports the ability for different parts of the string to be styled seperately.",},{number:1220,tracked:false,hits:0,text:" +",},{number:1221,tracked:false,hits:0,text:" + This struct is highly flexible and dynamic, as it requires the use of external code to provide some",},{number:1222,tracked:false,hits:0,text:" + of the implementation.",},{number:1223,tracked:false,hits:0,text:" +",},{number:1224,tracked:false,hits:0,text:" + Because this is provided via a `mixin template`, implementations can also $(B extend) this struct to ",},{number:1225,tracked:false,hits:0,text:" + provide their own functionality, make things non-copyable if needed, allows data to be stored via ref-counting, etc.",},{number:1226,tracked:false,hits:0,text:" +",},{number:1227,tracked:false,hits:0,text:" + This struct itself is mostly just a consistant user-facing interface that all implementations share, while the implementations",},{number:1228,tracked:false,hits:0,text:" + themselves can transform this struct to any level it requires.",},{number:1229,tracked:false,hits:0,text:" +",},{number:1230,tracked:false,hits:0,text:" + Implementations_:",},{number:1231,tracked:false,hits:0,text:" +  While implementations can add whatever functions, operator overloads, constructors, etc. that they want, there is a small",},{number:1232,tracked:false,hits:0,text:" +  set of functions and value that each implmentation must define in order to be useable.",},{number:1233,tracked:false,hits:0,text:" +",},{number:1234,tracked:false,hits:0,text:" +  Every implementation must define an enum called `Features` who's value is one of the values of `AnsiTextImplementationFeatures`.",},{number:1235,tracked:false,hits:0,text:" +  For example: `enum Features = AnsiTextImplementationFeatures.xxx`",},{number:1236,tracked:false,hits:0,text:" +",},{number:1237,tracked:false,hits:0,text:" +  Builtin implementations consist of `AnsiTextGC` (not enabled with -betterC), `AnsiTextStack`, and `AnsiTextMalloc`, which are self-descriptive.",},{number:1238,tracked:false,hits:0,text:" +",},{number:1239,tracked:false,hits:0,text:" + Basic_Implemetations:",},{number:1240,tracked:false,hits:0,text:" +  An implementation that doesn't require anything noteworthy from `AnsiText` itself should define their features as `AnsiTextImplementationFeatures.basic`.",},{number:1241,tracked:false,hits:0,text:" +",},{number:1242,tracked:false,hits:0,text:" +  This type of implementation must implement the following functions (expressed here as an interface for simplicity):",},{number:1243,tracked:false,hits:0,text:" +",},{number:1244,tracked:false,hits:0,text:" +  ```",},{number:1245,tracked:false,hits:0,text:" interface BasicImplementation",},{number:1246,tracked:false,hits:0,text:" {",},{number:1247,tracked:false,hits:0,text:"     /// Provides `AnsiText` with a slice that is of at least `minLength` in size.",},{number:1248,tracked:false,hits:0,text:"     ///",},{number:1249,tracked:false,hits:0,text:"     /// This function is called `AnsiText` needs to insert more styled characters into the string.",},{number:1250,tracked:false,hits:0,text:"     ///",},{number:1251,tracked:false,hits:0,text:"     /// How this slice is stored and allocated and whatever else, is completely down to the implementation.",},{number:1252,tracked:false,hits:0,text:"     /// Remember that because you're a mixin template, you can use referencing counting, disable the copy ctor, etc!",},{number:1253,tracked:false,hits:0,text:"     ///",},{number:1254,tracked:false,hits:0,text:"     /// The slice will never be escaped by `AnsiText` itself, and will not be stored beyond a single function call.",},{number:1255,tracked:false,hits:0,text:"     char[] newSlice(size_t minLength);",},{number:1256,tracked:false,hits:0,text:"",},{number:1257,tracked:false,hits:0,text:"     /// Outputs the styled string into the provided sink.",},{number:1258,tracked:false,hits:0,text:"     ///",},{number:1259,tracked:false,hits:0,text:"     /// Typically this is an OutputRange that can handle `char[]`s, but it can really be whatever the implementation wants to support.",},{number:1260,tracked:false,hits:0,text:"     void toSink(Sink)(Sink sink);",},{number:1261,tracked:false,hits:0,text:"",},{number:1262,tracked:false,hits:0,text:"     static if(NotCompilingUnderBetterC && ImplementationDoesntDefineToString)",},{number:1263,tracked:false,hits:0,text:"     final string toString()",},{number:1264,tracked:false,hits:0,text:"     {",},{number:1265,tracked:false,hits:0,text:"         // Autogenerated GC-based implementation provided by `AnsiText`.",},{number:1266,tracked:false,hits:0,text:"         //",},{number:1267,tracked:false,hits:0,text:"         // For implementations where this can be generated, it just makes them a little easier for the user",},{number:1268,tracked:false,hits:0,text:"         // to use with things like `writeln`.",},{number:1269,tracked:false,hits:0,text:"         //",},{number:1270,tracked:false,hits:0,text:"         // The `static if` shows the conditions for this to happen.",},{number:1271,tracked:false,hits:0,text:"     }",},{number:1272,tracked:false,hits:0,text:" }",},{number:1273,tracked:false,hits:0,text:" +  ```",},{number:1274,tracked:false,hits:0,text:" + ++/",},{number:1275,tracked:false,hits:0,text:"struct AnsiText(alias ImplementationMixin)",},{number:1276,tracked:false,hits:0,text:"{",},{number:1277,tracked:false,hits:0,text:"    mixin ImplementationMixin;",},{number:1278,tracked:false,hits:0,text:"    alias ___TEST = TestAnsiTextImpl!(typeof(this));",},{number:1279,tracked:false,hits:0,text:"",},{number:1280,tracked:false,hits:0,text:"    void put()(const(char)[] text, AnsiColour fg = AnsiColour.init, AnsiColour bg = AnsiColour.bgInit, AnsiStyle style = AnsiStyle.init)",},{number:1281,tracked:false,hits:0,text:"    {",},{number:1282,tracked:true,hits:9,text:"        fg.isBg = IsBgColour.no;",},{number:1283,tracked:true,hits:9,text:"        bg.isBg = IsBgColour.yes;",},{number:1284,tracked:false,hits:0,text:"",},{number:1285,tracked:true,hits:9,text:"        char[AnsiStyleSet.MAX_CHARS_NEEDED] sequence;",},{number:1286,tracked:true,hits:9,text:"        auto sequenceSlice = AnsiStyleSet.init.fg(fg).bg(bg).style(style).toSequence(sequence);",},{number:1287,tracked:false,hits:0,text:"",},{number:1288,tracked:true,hits:9,text:"        auto minLength = ANSI_CSI.length + sequenceSlice.length + /*ANSI_COLOUR_END*/1 + text.length + ((sequenceSlice.length > 0) ? 2 : 1); // Last one is for the '0' or '0;'",},{number:1289,tracked:true,hits:9,text:"        char[] slice = this.newSlice(minLength);",},{number:1290,tracked:true,hits:9,text:"        size_t cursor;",},{number:1291,tracked:false,hits:0,text:"",},{number:1292,tracked:false,hits:0,text:"        void appendToSlice(const(char)[] source)",},{number:1293,tracked:false,hits:0,text:"        {",},{number:1294,tracked:true,hits:36,text:"            slice[cursor..cursor+source.length] = source[];",},{number:1295,tracked:true,hits:36,text:"            cursor += source.length;",},{number:1296,tracked:false,hits:0,text:"        }",},{number:1297,tracked:false,hits:0,text:"",},{number:1298,tracked:true,hits:9,text:"        appendToSlice(ANSI_CSI);",},{number:1299,tracked:true,hits:9,text:"        appendToSlice(\"0\"); // Reset all previous styling",},{number:1300,tracked:true,hits:9,text:"        if(sequenceSlice.length > 0)",},{number:1301,tracked:true,hits:6,text:"            slice[cursor++] = ANSI_SEPARATOR;",},{number:1302,tracked:true,hits:9,text:"        appendToSlice(sequenceSlice);",},{number:1303,tracked:true,hits:9,text:"        slice[cursor++] = ANSI_COLOUR_END;",},{number:1304,tracked:true,hits:9,text:"        appendToSlice(text);",},{number:1305,tracked:false,hits:0,text:"    }",},{number:1306,tracked:false,hits:0,text:"",},{number:1307,tracked:false,hits:0,text:"    /// ditto.",},{number:1308,tracked:false,hits:0,text:"    void put()(const(char)[] text, AnsiStyleSet styling)",},{number:1309,tracked:false,hits:0,text:"    {",},{number:1310,tracked:false,hits:0,text:"        this.put(text, styling.fg, styling.bg, styling.style);",},{number:1311,tracked:false,hits:0,text:"    }",},{number:1312,tracked:false,hits:0,text:"",},{number:1313,tracked:false,hits:0,text:"    /// ditto.",},{number:1314,tracked:false,hits:0,text:"    void put()(AnsiTextLite text)",},{number:1315,tracked:false,hits:0,text:"    {",},{number:1316,tracked:false,hits:0,text:"        this.put(text.text, text.fg, text.bg, text.style);",},{number:1317,tracked:false,hits:0,text:"    }",},{number:1318,tracked:false,hits:0,text:"",},{number:1319,tracked:false,hits:0,text:"    // Generate a GC-based toString if circumstances allow.",},{number:1320,tracked:false,hits:0,text:"    static if(",},{number:1321,tracked:false,hits:0,text:"        Features == AnsiTextImplementationFeatures.basic",},{number:1322,tracked:false,hits:0,text:"     && !__traits(hasMember, typeof(this), \"toString\")",},{number:1323,tracked:false,hits:0,text:"     && !BetterC",},{number:1324,tracked:false,hits:0,text:"     && __traits(compiles, { struct S{void put(const(char)[]){}} S s; typeof(this).init.toSink(s); }) // Check if this toSink can take a char[] output range.",},{number:1325,tracked:false,hits:0,text:"    )",},{number:1326,tracked:false,hits:0,text:"    {",},{number:1327,tracked:false,hits:0,text:"        /++",},{number:1328,tracked:false,hits:0,text:"         + [Not enabled with -betterC] Provides this `AnsiText` as a printable string.",},{number:1329,tracked:false,hits:0,text:"         +",},{number:1330,tracked:false,hits:0,text:"         + If the implementation is a basic implementation (see the documentation for `AnsiText`); if the",},{number:1331,tracked:false,hits:0,text:"         + implementation doesn't define its own `toString`, and if we're not compliling under -betterC, then",},{number:1332,tracked:false,hits:0,text:"         + `AnsiText` will generate this function on behalf of the implementation.",},{number:1333,tracked:false,hits:0,text:"         +",},{number:1334,tracked:false,hits:0,text:"         + Description:",},{number:1335,tracked:false,hits:0,text:"         +  For basic implementations this function will call `toSink` with an `Appender!(char[])` as the sink.",},{number:1336,tracked:false,hits:0,text:"         +",},{number:1337,tracked:false,hits:0,text:"         +  For $(B this default generated) implementation of `toString`, it is a seperate GC-allocated string so is",},{number:1338,tracked:false,hits:0,text:"         +  fine for any usage. If an implementation defines its own `toString` then it should also document what the lifetime",},{number:1339,tracked:false,hits:0,text:"         +  of its returned string is.",},{number:1340,tracked:false,hits:0,text:"         +",},{number:1341,tracked:false,hits:0,text:"         + Returns:",},{number:1342,tracked:false,hits:0,text:"         +  This `AnsiText` as a useable string.",},{number:1343,tracked:false,hits:0,text:"         + ++/",},{number:1344,tracked:false,hits:0,text:"        string toString()()",},{number:1345,tracked:false,hits:0,text:"        {",},{number:1346,tracked:false,hits:0,text:"            import std.array : Appender;",},{number:1347,tracked:false,hits:0,text:"            import std.exception : assumeUnique;",},{number:1348,tracked:false,hits:0,text:"",},{number:1349,tracked:true,hits:3,text:"            Appender!(char[]) output;",},{number:1350,tracked:true,hits:3,text:"            this.toSink(output);",},{number:1351,tracked:false,hits:0,text:"",},{number:1352,tracked:true,hits:6,text:"            return ()@trusted{return output.data.assumeUnique;}();",},{number:1353,tracked:false,hits:0,text:"        }",},{number:1354,tracked:false,hits:0,text:"",},{number:1355,tracked:false,hits:0,text:"        /++",},{number:1356,tracked:false,hits:0,text:"         + [Not enabled with -betterC] Provides the sink-based version of the autogenerated `toString`.",},{number:1357,tracked:false,hits:0,text:"         +",},{number:1358,tracked:false,hits:0,text:"         + This functions and is generated under the same conditions as the parameterless `toString`, except it",},{number:1359,tracked:false,hits:0,text:"         + supports the sink-based interface certain parts of Phobos recognises, helping to prevent needless allocations.",},{number:1360,tracked:false,hits:0,text:"         +",},{number:1361,tracked:false,hits:0,text:"         + This function simply wraps the given `sink` and forwards it to the implementation's `toSink` function, so there's no",},{number:1362,tracked:false,hits:0,text:"         + implicit GC overhead as with the other `toString`. (At least, not by `AnsiText` itself.)",},{number:1363,tracked:false,hits:0,text:"         + ++/",},{number:1364,tracked:false,hits:0,text:"        void toString(scope void delegate(const(char)[]) sink)",},{number:1365,tracked:false,hits:0,text:"        {",},{number:1366,tracked:false,hits:0,text:"            struct Sink",},{number:1367,tracked:false,hits:0,text:"            {",},{number:1368,tracked:false,hits:0,text:"                void put(const(char)[] slice)",},{number:1369,tracked:false,hits:0,text:"                {",},{number:1370,tracked:true,hits:0,text:"                    sink(slice);",},{number:1371,tracked:false,hits:0,text:"                }",},{number:1372,tracked:false,hits:0,text:"            }",},{number:1373,tracked:false,hits:0,text:"            ",},{number:1374,tracked:true,hits:0,text:"            Sink s;",},{number:1375,tracked:true,hits:0,text:"            this.toSink(s);",},{number:1376,tracked:false,hits:0,text:"        }",},{number:1377,tracked:false,hits:0,text:"    }",},{number:1378,tracked:false,hits:0,text:"}",},{number:1379,tracked:false,hits:0,text:"",},{number:1380,tracked:false,hits:0,text:"private template TestAnsiTextImpl(alias TextT)",},{number:1381,tracked:false,hits:0,text:"{",},{number:1382,tracked:false,hits:0,text:"    // Ensures that the implementation has the required functions, and that they can be used in every required way.",},{number:1383,tracked:false,hits:0,text:"    static assert(__traits(hasMember, TextT, \"Features\"),",},{number:1384,tracked:false,hits:0,text:"        \"Implementation must define: `enum Features = AnsiTextImplementationFeatures.xxx;`\"",},{number:1385,tracked:false,hits:0,text:"    );",},{number:1386,tracked:false,hits:0,text:"",},{number:1387,tracked:false,hits:0,text:"    static if(TextT.Features == AnsiTextImplementationFeatures.basic)",},{number:1388,tracked:false,hits:0,text:"    {",},{number:1389,tracked:false,hits:0,text:"        static assert(__traits(hasMember, TextT, \"newSlice\"),",},{number:1390,tracked:false,hits:0,text:"            \"Implementation must define: `char[] newSlice(size_t minLength)`\"",},{number:1391,tracked:false,hits:0,text:"        );",},{number:1392,tracked:false,hits:0,text:"        static assert(__traits(hasMember, TextT, \"toSink\"),",},{number:1393,tracked:false,hits:0,text:"            \"Implementation must define: `void toSink(Sink)(Sink sink)`\"",},{number:1394,tracked:false,hits:0,text:"        );",},{number:1395,tracked:false,hits:0,text:"    }",},{number:1396,tracked:false,hits:0,text:"}",},{number:1397,tracked:false,hits:0,text:"",},{number:1398,tracked:false,hits:0,text:"@(\"AnsiText.toString - Autogenerated GC-based\")",},{number:1399,tracked:false,hits:0,text:"unittest",},{number:1400,tracked:false,hits:0,text:"{",},{number:1401,tracked:false,hits:0,text:"    static if(!BetterC)",},{number:1402,tracked:false,hits:0,text:"    {",},{number:1403,tracked:false,hits:0,text:"        import std.format : format;",},{number:1404,tracked:false,hits:0,text:"",},{number:1405,tracked:false,hits:0,text:"        void genericTest(AnsiTextT)(auto ref AnsiTextT text)",},{number:1406,tracked:false,hits:0,text:"        {",},{number:1407,tracked:true,hits:3,text:"            text.put(\"Hello, \");",},{number:1408,tracked:true,hits:3,text:"            text.put(\"Wor\", AnsiColour(1, 2, 3), AnsiColour(3, 2, 1), AnsiStyle.init.bold.underline);",},{number:1409,tracked:true,hits:3,text:"            text.put(\"ld!\", AnsiColour(Ansi4BitColour.green));",},{number:1410,tracked:false,hits:0,text:"",},{number:1411,tracked:true,hits:3,text:"            auto str      = text.toString();",},{number:1412,tracked:true,hits:3,text:"            auto expected = \"\\033[0mHello, \\033[0;38;2;1;2;3;48;2;3;2;1;1;4mWor\\033[0;32mld!\\033[0m\";",},{number:1413,tracked:false,hits:0,text:"",},{number:1414,tracked:true,hits:3,text:"            assert(",},{number:1415,tracked:false,hits:0,text:"                str == expected, ",},{number:1416,tracked:false,hits:0,text:"                \"Got is %s chars long. Expected is %s chars long\\nGot: %s\\nExp: %s\".format(str.length, expected.length, [str], [expected])",},{number:1417,tracked:false,hits:0,text:"            );",},{number:1418,tracked:false,hits:0,text:"",},{number:1419,tracked:false,hits:0,text:"            version(JANSI_TestOutput)",},{number:1420,tracked:false,hits:0,text:"            {",},{number:1421,tracked:false,hits:0,text:"                import std.stdio, std.traits;",},{number:1422,tracked:false,hits:0,text:"                static if(isCopyable!AnsiTextT)",},{number:1423,tracked:false,hits:0,text:"                    writeln(text);",},{number:1424,tracked:false,hits:0,text:"            }",},{number:1425,tracked:false,hits:0,text:"        }",},{number:1426,tracked:false,hits:0,text:"",},{number:1427,tracked:true,hits:1,text:"        genericTest(AnsiTextGC.init);",},{number:1428,tracked:true,hits:1,text:"        genericTest(AnsiTextMalloc.init);",},{number:1429,tracked:true,hits:1,text:"        genericTest(AnsiTextStack!100.init);",},{number:1430,tracked:false,hits:0,text:"    }",},{number:1431,tracked:false,hits:0,text:"}",},{number:1432,tracked:false,hits:0,text:"",},{number:1433,tracked:false,hits:0,text:"static if(!BetterC)",},{number:1434,tracked:false,hits:0,text:"{",},{number:1435,tracked:false,hits:0,text:"    // Very naive implementation just so I have something to start off with.",},{number:1436,tracked:false,hits:0,text:"    ///",},{number:1437,tracked:false,hits:0,text:"    mixin template AnsiTextGCImplementation()",},{number:1438,tracked:false,hits:0,text:"    {",},{number:1439,tracked:false,hits:0,text:"        private char[][] _slices;",},{number:1440,tracked:false,hits:0,text:"",},{number:1441,tracked:false,hits:0,text:"        enum Features = AnsiTextImplementationFeatures.basic;",},{number:1442,tracked:false,hits:0,text:"",},{number:1443,tracked:false,hits:0,text:"        @safe",},{number:1444,tracked:false,hits:0,text:"        char[] newSlice(size_t minLength) nothrow",},{number:1445,tracked:false,hits:0,text:"        {",},{number:1446,tracked:true,hits:3,text:"            this._slices ~= new char[minLength];",},{number:1447,tracked:true,hits:3,text:"            return this._slices[$-1];",},{number:1448,tracked:false,hits:0,text:"        }",},{number:1449,tracked:false,hits:0,text:"",},{number:1450,tracked:false,hits:0,text:"        void toSink(Sink)(ref scope Sink sink)",},{number:1451,tracked:false,hits:0,text:"        if(isOutputRange!(Sink, char[]))",},{number:1452,tracked:false,hits:0,text:"        {",},{number:1453,tracked:true,hits:12,text:"            foreach(slice; this._slices)",},{number:1454,tracked:true,hits:3,text:"                sink.put(slice);",},{number:1455,tracked:true,hits:1,text:"            sink.put(ANSI_COLOUR_RESET);",},{number:1456,tracked:false,hits:0,text:"        }",},{number:1457,tracked:false,hits:0,text:"    }",},{number:1458,tracked:false,hits:0,text:"",},{number:1459,tracked:false,hits:0,text:"    /++",},{number:1460,tracked:false,hits:0,text:"     + A basic implementation that uses the GC for memory storage.",},{number:1461,tracked:false,hits:0,text:"     +",},{number:1462,tracked:false,hits:0,text:"     + Since the memory is GC allocated there's no real fears to note.",},{number:1463,tracked:false,hits:0,text:"     +",},{number:1464,tracked:false,hits:0,text:"     + Allows `AnsiText` to be copied, but changes between copies are not reflected between eachother. Remember to use `ref`!",},{number:1465,tracked:false,hits:0,text:"     + ++/",},{number:1466,tracked:false,hits:0,text:"    alias AnsiTextGC = AnsiText!AnsiTextGCImplementation;",},{number:1467,tracked:false,hits:0,text:"}",},{number:1468,tracked:false,hits:0,text:"",},{number:1469,tracked:false,hits:0,text:"///",},{number:1470,tracked:false,hits:0,text:"mixin template AnsiTextMallocImplementation()",},{number:1471,tracked:false,hits:0,text:"{",},{number:1472,tracked:false,hits:0,text:"    import std.experimental.allocator.mallocator, std.experimental.allocator;",},{number:1473,tracked:false,hits:0,text:"",},{number:1474,tracked:false,hits:0,text:"    enum Features = AnsiTextImplementationFeatures.basic;",},{number:1475,tracked:false,hits:0,text:"",},{number:1476,tracked:false,hits:0,text:"    // Again, very naive implementation just to get stuff to show off.",},{number:1477,tracked:false,hits:0,text:"    private char[][] _slices;",},{number:1478,tracked:false,hits:0,text:"",},{number:1479,tracked:false,hits:0,text:"    // Stuff like this is why I went for this very strange design decision of using user-defined mixin templates.",},{number:1480,tracked:false,hits:0,text:"    @disable this(this){}",},{number:1481,tracked:false,hits:0,text:"",},{number:1482,tracked:false,hits:0,text:"    @nogc",},{number:1483,tracked:false,hits:0,text:"    ~this() nothrow",},{number:1484,tracked:false,hits:0,text:"    {",},{number:1485,tracked:true,hits:1,text:"        if(this._slices !is null)",},{number:1486,tracked:false,hits:0,text:"        {",},{number:1487,tracked:true,hits:12,text:"            foreach(slice; this._slices)",},{number:1488,tracked:true,hits:3,text:"                Mallocator.instance.dispose(slice);",},{number:1489,tracked:true,hits:1,text:"            Mallocator.instance.dispose(this._slices);",},{number:1490,tracked:false,hits:0,text:"        }",},{number:1491,tracked:false,hits:0,text:"    }",},{number:1492,tracked:false,hits:0,text:"",},{number:1493,tracked:false,hits:0,text:"    @nogc",},{number:1494,tracked:false,hits:0,text:"    char[] newSlice(size_t minLength) nothrow",},{number:1495,tracked:false,hits:0,text:"    {",},{number:1496,tracked:true,hits:3,text:"        auto slice = Mallocator.instance.makeArray!char(minLength);",},{number:1497,tracked:true,hits:3,text:"        if(this._slices is null)",},{number:1498,tracked:true,hits:1,text:"            this._slices = Mallocator.instance.makeArray!(char[])(1);",},{number:1499,tracked:false,hits:0,text:"        else",},{number:1500,tracked:true,hits:2,text:"            Mallocator.instance.expandArray(this._slices, 1);",},{number:1501,tracked:true,hits:3,text:"        this._slices[$-1] = slice;",},{number:1502,tracked:true,hits:3,text:"        return slice;",},{number:1503,tracked:false,hits:0,text:"    }",},{number:1504,tracked:false,hits:0,text:"",},{number:1505,tracked:false,hits:0,text:"    void toSink(Sink)(ref scope Sink sink)",},{number:1506,tracked:false,hits:0,text:"    if(isOutputRange!(Sink, char[]))",},{number:1507,tracked:false,hits:0,text:"    {",},{number:1508,tracked:true,hits:12,text:"        foreach(slice; this._slices)",},{number:1509,tracked:true,hits:3,text:"            sink.put(slice);",},{number:1510,tracked:true,hits:1,text:"        sink.put(ANSI_COLOUR_RESET);",},{number:1511,tracked:false,hits:0,text:"    }",},{number:1512,tracked:false,hits:0,text:"}",},{number:1513,tracked:false,hits:0,text:"",},{number:1514,tracked:false,hits:0,text:"/++",},{number:1515,tracked:false,hits:0,text:" + A basic implementation using `malloc` backed memory.",},{number:1516,tracked:false,hits:0,text:" +",},{number:1517,tracked:false,hits:0,text:" + This implementation disables copying for `AnsiText`, as it makes use of RAII to cleanup its resources.",},{number:1518,tracked:false,hits:0,text:" +",},{number:1519,tracked:false,hits:0,text:" + Sinks should keep in mind that they are being passed manually managed memory, so it should be considered an error",},{number:1520,tracked:false,hits:0,text:" + if the sink stores any provided slices outside of its `.put` function. i.e. Copy the data, don't keep it around unless you know what you're doing.",},{number:1521,tracked:false,hits:0,text:" + ++/",},{number:1522,tracked:false,hits:0,text:"alias AnsiTextMalloc = AnsiText!AnsiTextMallocImplementation;",},{number:1523,tracked:false,hits:0,text:"",},{number:1524,tracked:false,hits:0,text:"///",},{number:1525,tracked:false,hits:0,text:"template AnsiTextStackImplementation(size_t Capacity)",},{number:1526,tracked:false,hits:0,text:"{",},{number:1527,tracked:false,hits:0,text:"    mixin template AnsiTextStackImplementation()",},{number:1528,tracked:false,hits:0,text:"    {",},{number:1529,tracked:false,hits:0,text:"        enum Features = AnsiTextImplementationFeatures.basic;",},{number:1530,tracked:false,hits:0,text:"",},{number:1531,tracked:false,hits:0,text:"        private char[Capacity] _output;",},{number:1532,tracked:false,hits:0,text:"        private size_t _cursor;",},{number:1533,tracked:false,hits:0,text:"",},{number:1534,tracked:false,hits:0,text:"        // This code by itself is *technically* safe, but the way the user uses it might not be.",},{number:1535,tracked:false,hits:0,text:"",},{number:1536,tracked:false,hits:0,text:"        @safe @nogc",},{number:1537,tracked:false,hits:0,text:"        char[] newSlice(size_t minLength) nothrow",},{number:1538,tracked:false,hits:0,text:"        {",},{number:1539,tracked:true,hits:3,text:"            const end = this._cursor + minLength;",},{number:1540,tracked:true,hits:3,text:"            assert(end <= this._output.length, \"Ran out of space.\");",},{number:1541,tracked:false,hits:0,text:"",},{number:1542,tracked:true,hits:3,text:"            auto slice = this._output[this._cursor..end];",},{number:1543,tracked:true,hits:3,text:"            this._cursor = end;",},{number:1544,tracked:false,hits:0,text:"",},{number:1545,tracked:true,hits:3,text:"            return slice;",},{number:1546,tracked:false,hits:0,text:"        }",},{number:1547,tracked:false,hits:0,text:"",},{number:1548,tracked:false,hits:0,text:"        void toSink(Sink)(ref Sink sink)",},{number:1549,tracked:false,hits:0,text:"        if(isOutputRange!(Sink, char[]))",},{number:1550,tracked:false,hits:0,text:"        {",},{number:1551,tracked:true,hits:1,text:"            sink.put(this.asStackSlice);",},{number:1552,tracked:true,hits:1,text:"            sink.put(ANSI_COLOUR_RESET);",},{number:1553,tracked:false,hits:0,text:"        }",},{number:1554,tracked:false,hits:0,text:"",},{number:1555,tracked:false,hits:0,text:"        @safe @nogc",},{number:1556,tracked:false,hits:0,text:"        char[] asStackSlice() nothrow",},{number:1557,tracked:false,hits:0,text:"        {",},{number:1558,tracked:true,hits:1,text:"            return this._output[0..this._cursor];    ",},{number:1559,tracked:false,hits:0,text:"        }",},{number:1560,tracked:false,hits:0,text:"",},{number:1561,tracked:false,hits:0,text:"        @safe @nogc",},{number:1562,tracked:false,hits:0,text:"        char[Capacity] asStackSliceCopy(ref size_t lengthInUse) nothrow",},{number:1563,tracked:false,hits:0,text:"        {",},{number:1564,tracked:true,hits:0,text:"            lengthInUse = this._cursor;",},{number:1565,tracked:true,hits:0,text:"            return this._output;",},{number:1566,tracked:false,hits:0,text:"        }",},{number:1567,tracked:false,hits:0,text:"    }",},{number:1568,tracked:false,hits:0,text:"}",},{number:1569,tracked:false,hits:0,text:"",},{number:1570,tracked:false,hits:0,text:"/++",},{number:1571,tracked:false,hits:0,text:" + A basic implementation using a static amount of stack memory.",},{number:1572,tracked:false,hits:0,text:" +",},{number:1573,tracked:false,hits:0,text:" + Sinks should keep in mind that they're being passed a slice to stack memory, so should not persist slices outside of their `.put` function,",},{number:1574,tracked:false,hits:0,text:" + they must instead make a copy of the data.",},{number:1575,tracked:false,hits:0,text:" +",},{number:1576,tracked:false,hits:0,text:" + This implementation will fail an assert if the user attempts to push more data into it than it can handle.",},{number:1577,tracked:false,hits:0,text:" +",},{number:1578,tracked:false,hits:0,text:" + Params:",},{number:1579,tracked:false,hits:0,text:" +  Capacity = The amount of characters to use on the stack.",},{number:1580,tracked:false,hits:0,text:" + ++/",},{number:1581,tracked:false,hits:0,text:"alias AnsiTextStack(size_t Capacity) = AnsiText!(AnsiTextStackImplementation!Capacity);",},{number:1582,tracked:false,hits:0,text:"",},{number:1583,tracked:false,hits:0,text:"/+++ READING/PARSING +++/",},{number:1584,tracked:false,hits:0,text:"",},{number:1585,tracked:false,hits:0,text:"/++",},{number:1586,tracked:false,hits:0,text:" + Executes the SGR sequence found in `input`, and populates the passed in `style` based on the command sequence.",},{number:1587,tracked:false,hits:0,text:" +",},{number:1588,tracked:false,hits:0,text:" + Anything directly provided by this library is supported.",},{number:1589,tracked:false,hits:0,text:" +",},{number:1590,tracked:false,hits:0,text:" + The previous state of `style` is preserved unless specifically untoggled/reset via the command sequence (e.g. `ESC[0m` to reset everything).",},{number:1591,tracked:false,hits:0,text:" +",},{number:1592,tracked:false,hits:0,text:" + If an error occurs during execution of the sequence, the given `style` is left completely unmodified.",},{number:1593,tracked:false,hits:0,text:" +",},{number:1594,tracked:false,hits:0,text:" + Params:",},{number:1595,tracked:false,hits:0,text:" +  input     = The slice containing the command sequence. The first character should be the start (`ANSI_CSI`) character of the sequence (`\\033`), and",},{number:1596,tracked:false,hits:0,text:" +              characters will continue to be read until the command sequence has been finished. Any characters after the command sequence are left unread.",},{number:1597,tracked:false,hits:0,text:" +  style     = A reference to an `AnsiStyleSet` to populate. As mentioned, this function will only untoggle styling, or reset the style if the command sequence specifies.",},{number:1598,tracked:false,hits:0,text:" +              This value is left unmodified if an error is encountered.",},{number:1599,tracked:false,hits:0,text:" +  charsRead = This value will be set to the amount of chars read from the given `input`, so the caller knows where to continue reading from (if applicable).",},{number:1600,tracked:false,hits:0,text:" +              This value is populated on both error and success.",},{number:1601,tracked:false,hits:0,text:" +",},{number:1602,tracked:false,hits:0,text:" + Returns:",},{number:1603,tracked:false,hits:0,text:" +  Either `null` on success, or a string describing the error that was encountered.",},{number:1604,tracked:false,hits:0,text:" + ++/",},{number:1605,tracked:false,hits:0,text:"@safe @nogc",},{number:1606,tracked:false,hits:0,text:"string ansiExecuteSgrSequence(const(char)[] input, ref AnsiStyleSet style, out size_t charsRead) nothrow",},{number:1607,tracked:false,hits:0,text:"{",},{number:1608,tracked:false,hits:0,text:"    import std.traits : EnumMembers;",},{number:1609,tracked:false,hits:0,text:"",},{number:1610,tracked:false,hits:0,text:"    enum ReadResult { foundEndMarker, foundSemiColon, foundEnd, foundBadCharacter }",},{number:1611,tracked:false,hits:0,text:"",},{number:1612,tracked:true,hits:20,text:"    if(input.length < 3)",},{number:1613,tracked:true,hits:0,text:"        return \"A valid SGR is at least 3 characters long: ESC[m\";",},{number:1614,tracked:false,hits:0,text:"",},{number:1615,tracked:true,hits:20,text:"    if(input[0..ANSI_CSI.length] != ANSI_CSI)",},{number:1616,tracked:true,hits:0,text:"        return \"Input does not start with the CSI: ESC[\";",},{number:1617,tracked:false,hits:0,text:"",},{number:1618,tracked:true,hits:20,text:"    auto styleCopy = style;",},{number:1619,tracked:false,hits:0,text:"",},{number:1620,tracked:true,hits:20,text:"    charsRead = 2;",},{number:1621,tracked:false,hits:0,text:"    ReadResult readToSemiColonOrEndMarker(ref const(char)[] slice)",},{number:1622,tracked:false,hits:0,text:"    {",},{number:1623,tracked:true,hits:50,text:"        const start = charsRead;",},{number:1624,tracked:true,hits:140,text:"        while(true)",},{number:1625,tracked:false,hits:0,text:"        {",},{number:1626,tracked:true,hits:140,text:"            if(charsRead >= input.length)",},{number:1627,tracked:true,hits:0,text:"                return ReadResult.foundEnd;",},{number:1628,tracked:false,hits:0,text:"",},{number:1629,tracked:true,hits:140,text:"            const ch = input[charsRead];",},{number:1630,tracked:true,hits:140,text:"            if(ch == 'm')",},{number:1631,tracked:false,hits:0,text:"            {",},{number:1632,tracked:true,hits:20,text:"                slice = input[start..charsRead];",},{number:1633,tracked:true,hits:20,text:"                return ReadResult.foundEndMarker;",},{number:1634,tracked:false,hits:0,text:"            }",},{number:1635,tracked:true,hits:120,text:"            else if(ch == ';')",},{number:1636,tracked:false,hits:0,text:"            {",},{number:1637,tracked:true,hits:30,text:"                slice = input[start..charsRead];",},{number:1638,tracked:true,hits:30,text:"                return ReadResult.foundSemiColon;",},{number:1639,tracked:false,hits:0,text:"            }",},{number:1640,tracked:true,hits:180,text:"            else if(ch >= '0' && ch <= '9')",},{number:1641,tracked:false,hits:0,text:"            {",},{number:1642,tracked:true,hits:90,text:"                charsRead++;",},{number:1643,tracked:true,hits:90,text:"                continue;",},{number:1644,tracked:false,hits:0,text:"            }",},{number:1645,tracked:false,hits:0,text:"            else",},{number:1646,tracked:true,hits:0,text:"                return ReadResult.foundBadCharacter;",},{number:1647,tracked:false,hits:0,text:"        }",},{number:1648,tracked:false,hits:0,text:"    }",},{number:1649,tracked:false,hits:0,text:"",},{number:1650,tracked:false,hits:0,text:"    int toValue(const(char)[] slice)",},{number:1651,tracked:false,hits:0,text:"    {",},{number:1652,tracked:true,hits:50,text:"        return (slice.length == 0) ? 0 : slice.strToNum!int;",},{number:1653,tracked:false,hits:0,text:"    }",},{number:1654,tracked:false,hits:0,text:"",},{number:1655,tracked:false,hits:0,text:"    string resultToString(ReadResult result)",},{number:1656,tracked:false,hits:0,text:"    {",},{number:1657,tracked:true,hits:0,text:"        final switch(result) with(ReadResult)",},{number:1658,tracked:false,hits:0,text:"        {",},{number:1659,tracked:true,hits:0,text:"            case foundEnd: return \"Unexpected end of input.\";",},{number:1660,tracked:true,hits:0,text:"            case foundBadCharacter: return \"Unexpected character in input.\";",},{number:1661,tracked:false,hits:0,text:"",},{number:1662,tracked:true,hits:0,text:"            case foundSemiColon: return \"Unexpected semi-colon.\";",},{number:1663,tracked:true,hits:0,text:"            case foundEndMarker: return \"Unexpected end marker ('m').\";",},{number:1664,tracked:false,hits:0,text:"        }",},{number:1665,tracked:false,hits:0,text:"    }",},{number:1666,tracked:false,hits:0,text:"",},{number:1667,tracked:true,hits:20,text:"    const(char)[] generalSlice;",},{number:1668,tracked:true,hits:50,text:"    while(charsRead < input.length)",},{number:1669,tracked:false,hits:0,text:"    {",},{number:1670,tracked:true,hits:50,text:"        const ch = input[charsRead];",},{number:1671,tracked:false,hits:0,text:"",},{number:1672,tracked:true,hits:50,text:"        switch(ch)",},{number:1673,tracked:false,hits:0,text:"        {",},{number:1674,tracked:true,hits:161,text:"            case '0':..case '9':",},{number:1675,tracked:true,hits:26,text:"                auto result = readToSemiColonOrEndMarker(generalSlice);",},{number:1676,tracked:true,hits:40,text:"                if(result != ReadResult.foundSemiColon && result != ReadResult.foundEndMarker)",},{number:1677,tracked:true,hits:0,text:"                    return resultToString(result);",},{number:1678,tracked:false,hits:0,text:"",},{number:1679,tracked:true,hits:26,text:"                const commandAsNum = toValue(generalSlice);",},{number:1680,tracked:true,hits:26,text:"                Switch: switch(commandAsNum)",},{number:1681,tracked:false,hits:0,text:"                {",},{number:1682,tracked:false,hits:0,text:"                    // Full reset",},{number:1683,tracked:true,hits:0,text:"                    case 0: styleCopy = AnsiStyleSet.init; break;",},{number:1684,tracked:false,hits:0,text:"",},{number:1685,tracked:false,hits:0,text:"                    // Basic style flag setters.",},{number:1686,tracked:false,hits:0,text:"                    static foreach(member; EnumMembers!AnsiSgrStyle)",},{number:1687,tracked:false,hits:0,text:"                    {",},{number:1688,tracked:false,hits:0,text:"                        static if(member != AnsiSgrStyle.none)",},{number:1689,tracked:false,hits:0,text:"                        {",},{number:1690,tracked:true,hits:12,text:"                            case cast(int)member:",},{number:1691,tracked:true,hits:12,text:"                                styleCopy.style = styleCopy.style.set(member, true);",},{number:1692,tracked:true,hits:12,text:"                                break Switch;",},{number:1693,tracked:false,hits:0,text:"                        }",},{number:1694,tracked:false,hits:0,text:"                    }",},{number:1695,tracked:false,hits:0,text:"",},{number:1696,tracked:false,hits:0,text:"                    // Set foreground to a 4-bit colour.",},{number:1697,tracked:true,hits:12,text:"                    case 30:..case 37:",},{number:1698,tracked:true,hits:22,text:"                    case 90:..case 97:",},{number:1699,tracked:true,hits:3,text:"                        styleCopy.fg = cast(Ansi4BitColour)commandAsNum;",},{number:1700,tracked:true,hits:3,text:"                        break;",},{number:1701,tracked:false,hits:0,text:"",},{number:1702,tracked:false,hits:0,text:"                    // Set background to a 4-bit colour.",},{number:1703,tracked:true,hits:6,text:"                    case 40:..case 47:",},{number:1704,tracked:true,hits:21,text:"                    case 100:..case 107:",},{number:1705,tracked:true,hits:3,text:"                        styleCopy.bg = cast(Ansi4BitColour)(commandAsNum - ANSI_FG_TO_BG_INCREMENT); // Since we work in the foreground colour until we're outputting to sequences.",},{number:1706,tracked:true,hits:3,text:"                        break;",},{number:1707,tracked:false,hits:0,text:"                    ",},{number:1708,tracked:false,hits:0,text:"                    // Set foreground (38) or background (48) to an 8-bit (5) or 24-bit (2) colour.",},{number:1709,tracked:true,hits:4,text:"                    case 38:",},{number:1710,tracked:true,hits:8,text:"                    case 48:",},{number:1711,tracked:true,hits:8,text:"                        if(result == ReadResult.foundEndMarker)",},{number:1712,tracked:true,hits:0,text:"                            return \"Incomplete 'set foreground/background' command, expected another parameter, got none.\";",},{number:1713,tracked:true,hits:8,text:"                        charsRead++; // Skip semi-colon.",},{number:1714,tracked:false,hits:0,text:"",},{number:1715,tracked:true,hits:8,text:"                        result = readToSemiColonOrEndMarker(generalSlice);",},{number:1716,tracked:true,hits:16,text:"                        if(result != ReadResult.foundEndMarker && result != ReadResult.foundSemiColon)",},{number:1717,tracked:true,hits:0,text:"                            return resultToString(result);",},{number:1718,tracked:true,hits:8,text:"                        if(result == ReadResult.foundSemiColon)",},{number:1719,tracked:true,hits:8,text:"                            charsRead++;",},{number:1720,tracked:false,hits:0,text:"",},{number:1721,tracked:true,hits:8,text:"                        const subcommand = toValue(generalSlice);",},{number:1722,tracked:true,hits:8,text:"                        if(subcommand == 5)",},{number:1723,tracked:false,hits:0,text:"                        {",},{number:1724,tracked:true,hits:4,text:"                            result = readToSemiColonOrEndMarker(generalSlice);",},{number:1725,tracked:true,hits:5,text:"                            if(result != ReadResult.foundEndMarker && result != ReadResult.foundSemiColon)",},{number:1726,tracked:true,hits:0,text:"                                return resultToString(result);",},{number:1727,tracked:true,hits:4,text:"                            if(result == ReadResult.foundSemiColon)",},{number:1728,tracked:true,hits:1,text:"                                charsRead++;",},{number:1729,tracked:false,hits:0,text:"",},{number:1730,tracked:true,hits:6,text:"                            if(commandAsNum == 38) styleCopy.fg = cast(Ansi8BitColour)toValue(generalSlice);",},{number:1731,tracked:true,hits:2,text:"                            else                   styleCopy.bg = cast(Ansi8BitColour)toValue(generalSlice);",},{number:1732,tracked:false,hits:0,text:"                        }",},{number:1733,tracked:true,hits:4,text:"                        else if(subcommand == 2)",},{number:1734,tracked:false,hits:0,text:"                        {",},{number:1735,tracked:true,hits:4,text:"                            ubyte[3] components;",},{number:1736,tracked:true,hits:48,text:"                            foreach(i; 0..3)",},{number:1737,tracked:false,hits:0,text:"                            {",},{number:1738,tracked:true,hits:12,text:"                                result = readToSemiColonOrEndMarker(generalSlice);",},{number:1739,tracked:true,hits:21,text:"                                if(result != ReadResult.foundEndMarker && result != ReadResult.foundSemiColon)",},{number:1740,tracked:true,hits:0,text:"                                    return resultToString(result);",},{number:1741,tracked:true,hits:12,text:"                                if(result == ReadResult.foundSemiColon)",},{number:1742,tracked:true,hits:9,text:"                                    charsRead++;",},{number:1743,tracked:false,hits:0,text:"",},{number:1744,tracked:true,hits:12,text:"                                components[i] = cast(ubyte)toValue(generalSlice);",},{number:1745,tracked:false,hits:0,text:"                            }",},{number:1746,tracked:false,hits:0,text:"",},{number:1747,tracked:true,hits:6,text:"                            if(commandAsNum == 38) styleCopy.fg = AnsiRgbColour(components);",},{number:1748,tracked:true,hits:2,text:"                            else                   styleCopy.bg = AnsiRgbColour(components);",},{number:1749,tracked:false,hits:0,text:"                        }",},{number:1750,tracked:false,hits:0,text:"                        else",},{number:1751,tracked:true,hits:0,text:"                            break; // Assume it's a valid command, just that we don't support this specific sub command.",},{number:1752,tracked:true,hits:8,text:"                        break;",},{number:1753,tracked:false,hits:0,text:"",},{number:1754,tracked:true,hits:0,text:"                    default: continue; // Assume it's just a command we don't support.",},{number:1755,tracked:false,hits:0,text:"                }",},{number:1756,tracked:true,hits:26,text:"                break;",},{number:1757,tracked:false,hits:0,text:"",},{number:1758,tracked:true,hits:20,text:"            case 'm':",},{number:1759,tracked:true,hits:20,text:"                charsRead++;",},{number:1760,tracked:true,hits:20,text:"                style = styleCopy;",},{number:1761,tracked:true,hits:20,text:"                return null;",},{number:1762,tracked:false,hits:0,text:"",},{number:1763,tracked:true,hits:12,text:"            case ';': charsRead++; continue;",},{number:1764,tracked:true,hits:0,text:"            default: return null; // Assume we've hit an end-marker we don't support.",},{number:1765,tracked:false,hits:0,text:"        }",},{number:1766,tracked:false,hits:0,text:"    }",},{number:1767,tracked:false,hits:0,text:"",},{number:1768,tracked:true,hits:0,text:"    return \"Input did not contain an end marker.\";",},{number:1769,tracked:false,hits:0,text:"}",},{number:1770,tracked:false,hits:0,text:"///",},{number:1771,tracked:false,hits:0,text:"@(\"ansiExecuteSgrSequence\")",},{number:1772,tracked:false,hits:0,text:"unittest",},{number:1773,tracked:false,hits:0,text:"{",},{number:1774,tracked:false,hits:0,text:"    static if(!BetterC)",},{number:1775,tracked:false,hits:0,text:"    {",},{number:1776,tracked:false,hits:0,text:"        import std.conv : to;",},{number:1777,tracked:false,hits:0,text:"        import std.traits : EnumMembers;",},{number:1778,tracked:false,hits:0,text:"",},{number:1779,tracked:false,hits:0,text:"        void test(AnsiStyleSet sourceAndExpected)",},{number:1780,tracked:false,hits:0,text:"        {",},{number:1781,tracked:true,hits:20,text:"            char[AnsiStyleSet.MAX_CHARS_NEEDED] buffer;",},{number:1782,tracked:true,hits:20,text:"            const sequence = ANSI_CSI~sourceAndExpected.toSequence(buffer)~ANSI_COLOUR_END;",},{number:1783,tracked:false,hits:0,text:"",},{number:1784,tracked:true,hits:20,text:"            AnsiStyleSet got;",},{number:1785,tracked:true,hits:20,text:"            size_t charsRead;",},{number:1786,tracked:true,hits:20,text:"            const error = ansiExecuteSgrSequence(sequence, got, charsRead);",},{number:1787,tracked:true,hits:20,text:"            if(error !is null)",},{number:1788,tracked:false,hits:0,text:"                assert(false, error);",},{number:1789,tracked:false,hits:0,text:"",},{number:1790,tracked:true,hits:20,text:"            assert(charsRead == sequence.length, \"Read \"~charsRead.to!string~\" not \"~sequence.length.to!string);",},{number:1791,tracked:true,hits:20,text:"            assert(sourceAndExpected == got, \"Expected \"~sourceAndExpected.to!string~\" got \"~got.to!string);",},{number:1792,tracked:false,hits:0,text:"        }",},{number:1793,tracked:false,hits:0,text:"",},{number:1794,tracked:true,hits:1,text:"        test(AnsiStyleSet.init.fg(Ansi4BitColour.green));",},{number:1795,tracked:true,hits:1,text:"        test(AnsiStyleSet.init.fg(Ansi4BitColour.brightGreen));",},{number:1796,tracked:true,hits:1,text:"        test(AnsiStyleSet.init.bg(Ansi4BitColour.green));",},{number:1797,tracked:true,hits:1,text:"        test(AnsiStyleSet.init.bg(Ansi4BitColour.brightGreen));",},{number:1798,tracked:true,hits:1,text:"        test(AnsiStyleSet.init.fg(Ansi4BitColour.green).bg(Ansi4BitColour.brightRed));",},{number:1799,tracked:false,hits:0,text:"",},{number:1800,tracked:true,hits:1,text:"        test(AnsiStyleSet.init.fg(20));",},{number:1801,tracked:true,hits:1,text:"        test(AnsiStyleSet.init.bg(40));",},{number:1802,tracked:true,hits:1,text:"        test(AnsiStyleSet.init.fg(20).bg(40));",},{number:1803,tracked:false,hits:0,text:"",},{number:1804,tracked:true,hits:1,text:"        test(AnsiStyleSet.init.fg(AnsiRgbColour(255, 128, 64)));",},{number:1805,tracked:true,hits:1,text:"        test(AnsiStyleSet.init.bg(AnsiRgbColour(255, 128, 64)));",},{number:1806,tracked:true,hits:1,text:"        test(AnsiStyleSet.init.fg(AnsiRgbColour(255, 128, 64)).bg(AnsiRgbColour(64, 128, 255)));",},{number:1807,tracked:false,hits:0,text:"        ",},{number:1808,tracked:false,hits:0,text:"        static foreach(member; EnumMembers!AnsiSgrStyle)",},{number:1809,tracked:false,hits:0,text:"        static if(member != AnsiSgrStyle.none)",},{number:1810,tracked:true,hits:8,text:"            test(AnsiStyleSet.init.style(AnsiStyle.init.set(member, true)));",},{number:1811,tracked:false,hits:0,text:"",},{number:1812,tracked:true,hits:1,text:"        test(AnsiStyleSet.init.style(AnsiStyle.init.bold.underline.slowBlink.italic));",},{number:1813,tracked:false,hits:0,text:"    }",},{number:1814,tracked:false,hits:0,text:"}",},{number:1815,tracked:false,hits:0,text:"",},{number:1816,tracked:false,hits:0,text:"/++",},{number:1817,tracked:false,hits:0,text:" + The resulting object from `AnsiSectionRange`, describes whether a slice of text is an ANSI sequence or not.",},{number:1818,tracked:false,hits:0,text:" + ++/",},{number:1819,tracked:false,hits:0,text:"struct AnsiSection",},{number:1820,tracked:false,hits:0,text:"{",},{number:1821,tracked:false,hits:0,text:"    /// `true` if the slice is an ANSI sequence, `false` if it's just text.",},{number:1822,tracked:false,hits:0,text:"    bool isAnsiSequence;",},{number:1823,tracked:false,hits:0,text:"",},{number:1824,tracked:false,hits:0,text:"    /// The slice of text that this section consists of.",},{number:1825,tracked:false,hits:0,text:"    const(char)[] slice;",},{number:1826,tracked:false,hits:0,text:"}",},{number:1827,tracked:false,hits:0,text:"",},{number:1828,tracked:false,hits:0,text:"/++",},{number:1829,tracked:false,hits:0,text:" + An input range of `AnsiSection`s that splits a piece of text up into ANSI sequence and plain text sections.",},{number:1830,tracked:false,hits:0,text:" +",},{number:1831,tracked:false,hits:0,text:" + For example, the text \"\\033[37mABC\\033[0m\" has three sections: [ANSI \"\\033[37m\", TEXT \"ABC\", ANSI \"\\033[0m\"].",},{number:1832,tracked:false,hits:0,text:" + ++/",},{number:1833,tracked:false,hits:0,text:"struct AnsiSectionRange",},{number:1834,tracked:false,hits:0,text:"{",},{number:1835,tracked:false,hits:0,text:"    private",},{number:1836,tracked:false,hits:0,text:"    {",},{number:1837,tracked:false,hits:0,text:"        const(char)[] _input;",},{number:1838,tracked:false,hits:0,text:"        size_t        _cursor;",},{number:1839,tracked:false,hits:0,text:"        AnsiSection   _front;",},{number:1840,tracked:false,hits:0,text:"        bool          _empty = true; // So .init.empty is true",},{number:1841,tracked:false,hits:0,text:"    }",},{number:1842,tracked:false,hits:0,text:"    ",},{number:1843,tracked:false,hits:0,text:"    @safe @nogc nothrow pure:",},{number:1844,tracked:false,hits:0,text:"",},{number:1845,tracked:false,hits:0,text:"    ///",},{number:1846,tracked:true,hits:6,text:"    this(const(char)[] input)",},{number:1847,tracked:false,hits:0,text:"    {",},{number:1848,tracked:true,hits:6,text:"        this._input = input;",},{number:1849,tracked:true,hits:6,text:"        this._empty = false;",},{number:1850,tracked:true,hits:6,text:"        this.popFront();",},{number:1851,tracked:false,hits:0,text:"    }",},{number:1852,tracked:false,hits:0,text:"",},{number:1853,tracked:false,hits:0,text:"    ///",},{number:1854,tracked:false,hits:0,text:"    bool empty() const",},{number:1855,tracked:false,hits:0,text:"    {",},{number:1856,tracked:true,hits:21,text:"        return this._empty;",},{number:1857,tracked:false,hits:0,text:"    }",},{number:1858,tracked:false,hits:0,text:"    ",},{number:1859,tracked:false,hits:0,text:"    ///",},{number:1860,tracked:false,hits:0,text:"    AnsiSection front() const",},{number:1861,tracked:false,hits:0,text:"    {",},{number:1862,tracked:true,hits:18,text:"        return this._front;",},{number:1863,tracked:false,hits:0,text:"    }",},{number:1864,tracked:false,hits:0,text:"",},{number:1865,tracked:false,hits:0,text:"    ///",},{number:1866,tracked:false,hits:0,text:"    void popFront()",},{number:1867,tracked:false,hits:0,text:"    {",},{number:1868,tracked:true,hits:12,text:"        assert(!this.empty, \"Cannot pop empty range.\");",},{number:1869,tracked:false,hits:0,text:"",},{number:1870,tracked:true,hits:12,text:"        if(this._cursor >= this._input.length)",},{number:1871,tracked:false,hits:0,text:"        {",},{number:1872,tracked:true,hits:3,text:"            this._empty = true;",},{number:1873,tracked:true,hits:3,text:"            return;",},{number:1874,tracked:false,hits:0,text:"        }",},{number:1875,tracked:false,hits:0,text:"",},{number:1876,tracked:true,hits:9,text:"        if((this._input.length - this._cursor) >= ANSI_CSI.length ",},{number:1877,tracked:true,hits:9,text:"        && this._input[this._cursor..this._cursor + ANSI_CSI.length] == ANSI_CSI)",},{number:1878,tracked:true,hits:5,text:"            this.readSequence();",},{number:1879,tracked:false,hits:0,text:"        else",},{number:1880,tracked:true,hits:4,text:"            this.readText();",},{number:1881,tracked:false,hits:0,text:"    }",},{number:1882,tracked:false,hits:0,text:"",},{number:1883,tracked:false,hits:0,text:"    private void readText()",},{number:1884,tracked:false,hits:0,text:"    {",},{number:1885,tracked:true,hits:4,text:"        const start = this._cursor;",},{number:1886,tracked:false,hits:0,text:"        ",},{number:1887,tracked:true,hits:20,text:"        while(this._cursor < this._input.length)",},{number:1888,tracked:false,hits:0,text:"        {",},{number:1889,tracked:true,hits:34,text:"            if((this._input.length - this._cursor) >= 2 && this._input[this._cursor..this._cursor+2] == ANSI_CSI)",},{number:1890,tracked:true,hits:2,text:"                break;",},{number:1891,tracked:false,hits:0,text:"",},{number:1892,tracked:true,hits:16,text:"            this._cursor++;",},{number:1893,tracked:false,hits:0,text:"        }",},{number:1894,tracked:false,hits:0,text:"",},{number:1895,tracked:true,hits:4,text:"        this._front.isAnsiSequence = false;",},{number:1896,tracked:true,hits:4,text:"        this._front.slice = this._input[start..this._cursor];",},{number:1897,tracked:false,hits:0,text:"    }",},{number:1898,tracked:false,hits:0,text:"",},{number:1899,tracked:false,hits:0,text:"    private void readSequence()",},{number:1900,tracked:false,hits:0,text:"    {",},{number:1901,tracked:true,hits:5,text:"        const start = this._cursor;",},{number:1902,tracked:true,hits:5,text:"        this._cursor += ANSI_CSI.length; // Already validated by popFront.",},{number:1903,tracked:false,hits:0,text:"",},{number:1904,tracked:true,hits:31,text:"        while(this._cursor < this._input.length ",},{number:1905,tracked:true,hits:31,text:"           && this.isValidAnsiChar(this._input[this._cursor]))",},{number:1906,tracked:true,hits:26,text:"           this._cursor++;",},{number:1907,tracked:false,hits:0,text:"",},{number:1908,tracked:true,hits:5,text:"        if(this._cursor < this._input.length)",},{number:1909,tracked:true,hits:5,text:"            this._cursor++; // We've hit a non-ansi character, so we increment to include it in the output.",},{number:1910,tracked:false,hits:0,text:"",},{number:1911,tracked:true,hits:5,text:"        this._front.isAnsiSequence = true;",},{number:1912,tracked:true,hits:5,text:"        this._front.slice = this._input[start..this._cursor];",},{number:1913,tracked:false,hits:0,text:"    }",},{number:1914,tracked:false,hits:0,text:"",},{number:1915,tracked:false,hits:0,text:"    private bool isValidAnsiChar(char ch)",},{number:1916,tracked:false,hits:0,text:"    {",},{number:1917,tracked:true,hits:31,text:"        return (",},{number:1918,tracked:true,hits:31,text:"            (ch >= '0' && ch <= '9')",},{number:1919,tracked:true,hits:14,text:"         || ch == ';'",},{number:1920,tracked:false,hits:0,text:"        );",},{number:1921,tracked:false,hits:0,text:"    }",},{number:1922,tracked:false,hits:0,text:"}",},{number:1923,tracked:false,hits:0,text:"///",},{number:1924,tracked:false,hits:0,text:"@(\"AnsiSectionRange\")",},{number:1925,tracked:false,hits:0,text:"unittest",},{number:1926,tracked:false,hits:0,text:"{",},{number:1927,tracked:true,hits:1,text:"    assert(AnsiSectionRange.init.empty);",},{number:1928,tracked:true,hits:1,text:"    assert(\"\".asAnsiSections.empty);",},{number:1929,tracked:false,hits:0,text:"",},{number:1930,tracked:true,hits:1,text:"    auto r = \"No Ansi\".asAnsiSections;",},{number:1931,tracked:true,hits:1,text:"    assert(!r.empty);",},{number:1932,tracked:true,hits:1,text:"    assert(!r.front.isAnsiSequence);",},{number:1933,tracked:true,hits:1,text:"    assert(r.front.slice == \"No Ansi\");",},{number:1934,tracked:false,hits:0,text:"",},{number:1935,tracked:true,hits:1,text:"    r = \"\\033[m\".asAnsiSections;",},{number:1936,tracked:true,hits:1,text:"    assert(!r.empty);",},{number:1937,tracked:true,hits:1,text:"    assert(r.front.isAnsiSequence);",},{number:1938,tracked:true,hits:1,text:"    assert(r.front.slice == \"\\033[m\");",},{number:1939,tracked:false,hits:0,text:"",},{number:1940,tracked:true,hits:1,text:"    r = \"\\033[38;2;255;128;64;1;4;48;5;2m\".asAnsiSections;",},{number:1941,tracked:true,hits:1,text:"    assert(!r.empty);",},{number:1942,tracked:true,hits:1,text:"    assert(r.front.isAnsiSequence);",},{number:1943,tracked:true,hits:1,text:"    assert(r.front.slice == \"\\033[38;2;255;128;64;1;4;48;5;2m\");",},{number:1944,tracked:false,hits:0,text:"",},{number:1945,tracked:true,hits:1,text:"    r = \"\\033[mABC\\033[m\".asAnsiSections;",},{number:1946,tracked:true,hits:1,text:"    assert(r.front.isAnsiSequence);",},{number:1947,tracked:true,hits:1,text:"    assert(r.front.slice == \"\\033[m\", r.front.slice);",},{number:1948,tracked:true,hits:1,text:"    r.popFront();",},{number:1949,tracked:true,hits:1,text:"    assert(!r.empty);",},{number:1950,tracked:true,hits:1,text:"    assert(!r.front.isAnsiSequence);",},{number:1951,tracked:true,hits:1,text:"    assert(r.front.slice == \"ABC\", r.front.slice);",},{number:1952,tracked:true,hits:1,text:"    r.popFront();",},{number:1953,tracked:true,hits:1,text:"    assert(!r.empty);",},{number:1954,tracked:true,hits:1,text:"    assert(r.front.isAnsiSequence);",},{number:1955,tracked:true,hits:1,text:"    assert(r.front.slice == \"\\033[m\");",},{number:1956,tracked:true,hits:1,text:"    r.popFront();",},{number:1957,tracked:true,hits:1,text:"    assert(r.empty);",},{number:1958,tracked:false,hits:0,text:"",},{number:1959,tracked:true,hits:1,text:"    r = \"ABC\\033[mDEF\".asAnsiSections;",},{number:1960,tracked:true,hits:1,text:"    assert(!r.front.isAnsiSequence);",},{number:1961,tracked:true,hits:1,text:"    assert(r.front.slice == \"ABC\");",},{number:1962,tracked:true,hits:1,text:"    r.popFront();",},{number:1963,tracked:true,hits:1,text:"    assert(r.front.isAnsiSequence);",},{number:1964,tracked:true,hits:1,text:"    assert(r.front.slice == \"\\033[m\");",},{number:1965,tracked:true,hits:1,text:"    r.popFront();",},{number:1966,tracked:true,hits:1,text:"    assert(!r.front.isAnsiSequence);",},{number:1967,tracked:true,hits:1,text:"    assert(r.front.slice == \"DEF\");",},{number:1968,tracked:true,hits:1,text:"    r.popFront();",},{number:1969,tracked:true,hits:1,text:"    assert(r.empty);",},{number:1970,tracked:false,hits:0,text:"}",},{number:1971,tracked:false,hits:0,text:"",},{number:1972,tracked:false,hits:0,text:"/+++ PUBLIC HELPERS +++/",},{number:1973,tracked:false,hits:0,text:"",},{number:1974,tracked:false,hits:0,text:"/// Determines if `CT` is a valid RGB data type.",},{number:1975,tracked:false,hits:0,text:"enum isUserDefinedRgbType(CT) =",},{number:1976,tracked:false,hits:0,text:"(",},{number:1977,tracked:false,hits:0,text:"    __traits(hasMember, CT, \"r\")",},{number:1978,tracked:false,hits:0,text:" && __traits(hasMember, CT, \"g\")",},{number:1979,tracked:false,hits:0,text:" && __traits(hasMember, CT, \"b\")",},{number:1980,tracked:false,hits:0,text:");",},{number:1981,tracked:false,hits:0,text:"",},{number:1982,tracked:false,hits:0,text:"/++",},{number:1983,tracked:false,hits:0,text:" + Converts any suitable data type into an `AnsiColour`.",},{number:1984,tracked:false,hits:0,text:" +",},{number:1985,tracked:false,hits:0,text:" + Params:",},{number:1986,tracked:false,hits:0,text:" +  colour = The colour to convert.",},{number:1987,tracked:false,hits:0,text:" +",},{number:1988,tracked:false,hits:0,text:" + Returns:",},{number:1989,tracked:false,hits:0,text:" +  An `AnsiColour` created from the given `colour`.",},{number:1990,tracked:false,hits:0,text:" +",},{number:1991,tracked:false,hits:0,text:" + See_Also:",},{number:1992,tracked:false,hits:0,text:" +  `isUserDefinedRgbType`",},{number:1993,tracked:false,hits:0,text:" + ++/",},{number:1994,tracked:false,hits:0,text:"AnsiColour to(T : AnsiColour, CT)(CT colour)",},{number:1995,tracked:false,hits:0,text:"if(isUserDefinedRgbType!CT)",},{number:1996,tracked:false,hits:0,text:"{",},{number:1997,tracked:true,hits:2,text:"    return AnsiColour(colour.r, colour.g, colour.b);",},{number:1998,tracked:false,hits:0,text:"}",},{number:1999,tracked:false,hits:0,text:"///",},{number:2000,tracked:false,hits:0,text:"@(\"to!AnsiColour(User defined)\")",},{number:2001,tracked:false,hits:0,text:"@safe @nogc nothrow pure",},{number:2002,tracked:false,hits:0,text:"unittest",},{number:2003,tracked:false,hits:0,text:"{",},{number:2004,tracked:false,hits:0,text:"    static struct RGB",},{number:2005,tracked:false,hits:0,text:"    {",},{number:2006,tracked:false,hits:0,text:"        ubyte r;",},{number:2007,tracked:false,hits:0,text:"        ubyte g;",},{number:2008,tracked:false,hits:0,text:"        ubyte b;",},{number:2009,tracked:false,hits:0,text:"    }",},{number:2010,tracked:false,hits:0,text:"",},{number:2011,tracked:true,hits:1,text:"    assert(RGB(255, 128, 64).to!AnsiColour == AnsiColour(255, 128, 64));",},{number:2012,tracked:false,hits:0,text:"}",},{number:2013,tracked:false,hits:0,text:"",},{number:2014,tracked:false,hits:0,text:"/// ditto.",},{number:2015,tracked:false,hits:0,text:"AnsiColour toBg(T)(T c)",},{number:2016,tracked:false,hits:0,text:"{",},{number:2017,tracked:true,hits:1,text:"    auto colour = to!AnsiColour(c);",},{number:2018,tracked:true,hits:1,text:"    colour.isBg = IsBgColour.yes;",},{number:2019,tracked:true,hits:1,text:"    return colour;",},{number:2020,tracked:false,hits:0,text:"}",},{number:2021,tracked:false,hits:0,text:"///",},{number:2022,tracked:false,hits:0,text:"@(\"toBg\")",},{number:2023,tracked:false,hits:0,text:"@safe @nogc nothrow pure",},{number:2024,tracked:false,hits:0,text:"unittest",},{number:2025,tracked:false,hits:0,text:"{",},{number:2026,tracked:false,hits:0,text:"    static struct RGB",},{number:2027,tracked:false,hits:0,text:"    {",},{number:2028,tracked:false,hits:0,text:"        ubyte r;",},{number:2029,tracked:false,hits:0,text:"        ubyte g;",},{number:2030,tracked:false,hits:0,text:"        ubyte b;",},{number:2031,tracked:false,hits:0,text:"    }",},{number:2032,tracked:false,hits:0,text:"",},{number:2033,tracked:true,hits:1,text:"    assert(RGB(255, 128, 64).toBg == AnsiColour(255, 128, 64, IsBgColour.yes));",},{number:2034,tracked:false,hits:0,text:"}",},{number:2035,tracked:false,hits:0,text:"",},{number:2036,tracked:false,hits:0,text:"/++",},{number:2037,tracked:false,hits:0,text:" + Creates an `AnsiTextLite` from the given `text`. This function is mostly used when using",},{number:2038,tracked:false,hits:0,text:" + the fluent UFCS chaining pattern.",},{number:2039,tracked:false,hits:0,text:" +",},{number:2040,tracked:false,hits:0,text:" + Params:",},{number:2041,tracked:false,hits:0,text:" +  text = The text to use.",},{number:2042,tracked:false,hits:0,text:" +",},{number:2043,tracked:false,hits:0,text:" + Returns:",},{number:2044,tracked:false,hits:0,text:" +  An `AnsiTextLite` from the given `text`.",},{number:2045,tracked:false,hits:0,text:" + ++/",},{number:2046,tracked:false,hits:0,text:"@safe @nogc",},{number:2047,tracked:false,hits:0,text:"AnsiTextLite ansi(const(char)[] text) nothrow pure",},{number:2048,tracked:false,hits:0,text:"{",},{number:2049,tracked:true,hits:1,text:"    return AnsiTextLite(text);",},{number:2050,tracked:false,hits:0,text:"}",},{number:2051,tracked:false,hits:0,text:"///",},{number:2052,tracked:false,hits:0,text:"@(\"ansi\")",},{number:2053,tracked:false,hits:0,text:"unittest",},{number:2054,tracked:false,hits:0,text:"{",},{number:2055,tracked:false,hits:0,text:"    version(none)",},{number:2056,tracked:false,hits:0,text:"    {",},{number:2057,tracked:false,hits:0,text:"        import std.stdio;",},{number:2058,tracked:false,hits:0,text:"        writeln(\"Hello, World!\".ansi",},{number:2059,tracked:false,hits:0,text:"                               .fg(Ansi4BitColour.red)",},{number:2060,tracked:false,hits:0,text:"                               .bg(AnsiRgbColour(128, 128, 128))",},{number:2061,tracked:false,hits:0,text:"                               .style(AnsiStyle.init.bold.underline)",},{number:2062,tracked:false,hits:0,text:"        );",},{number:2063,tracked:false,hits:0,text:"    }",},{number:2064,tracked:false,hits:0,text:"}",},{number:2065,tracked:false,hits:0,text:"",},{number:2066,tracked:false,hits:0,text:"/++",},{number:2067,tracked:false,hits:0,text:" + Constructs an `AnsiSectionRange` from the given `slice`.",},{number:2068,tracked:false,hits:0,text:" + ++/",},{number:2069,tracked:false,hits:0,text:"@safe @nogc",},{number:2070,tracked:false,hits:0,text:"AnsiSectionRange asAnsiSections(const(char)[] slice) nothrow pure",},{number:2071,tracked:false,hits:0,text:"{",},{number:2072,tracked:true,hits:6,text:"    return AnsiSectionRange(slice);",},{number:2073,tracked:false,hits:0,text:"}",},{number:2074,tracked:false,hits:0,text:"",},{number:2075,tracked:false,hits:0,text:"/++",},{number:2076,tracked:false,hits:0,text:" + Enables ANSI support on windows via `SetConsoleMode`. This function is no-op on non-Windows platforms.",},{number:2077,tracked:false,hits:0,text:" + ++/",},{number:2078,tracked:false,hits:0,text:"void ansiEnableWindowsSupport() @nogc nothrow",},{number:2079,tracked:false,hits:0,text:"{",},{number:2080,tracked:false,hits:0,text:"    version(Windows)",},{number:2081,tracked:false,hits:0,text:"    {",},{number:2082,tracked:false,hits:0,text:"        import core.sys.windows.windows : HANDLE, DWORD, GetStdHandle, STD_OUTPUT_HANDLE, GetConsoleMode, SetConsoleMode, ENABLE_VIRTUAL_TERMINAL_PROCESSING;",},{number:2083,tracked:false,hits:0,text:"        HANDLE stdOut = GetStdHandle(STD_OUTPUT_HANDLE);",},{number:2084,tracked:false,hits:0,text:"        DWORD mode = 0;",},{number:2085,tracked:false,hits:0,text:"        GetConsoleMode(stdOut, &mode);",},{number:2086,tracked:false,hits:0,text:"        mode |= ENABLE_VIRTUAL_TERMINAL_PROCESSING;",},{number:2087,tracked:false,hits:0,text:"        SetConsoleMode(stdOut, mode);",},{number:2088,tracked:false,hits:0,text:"    }",},{number:2089,tracked:false,hits:0,text:"}",},{number:2090,tracked:false,hits:0,text:"",},{number:2091,tracked:false,hits:0,text:"/+++ PRIVATE HELPERS +++/",},{number:2092,tracked:false,hits:0,text:"private char[] numToStrBase10(NumT)(char[] buffer, NumT num)",},{number:2093,tracked:false,hits:0,text:"{",},{number:2094,tracked:true,hits:84,text:"    if(num == 0)",},{number:2095,tracked:false,hits:0,text:"    {",},{number:2096,tracked:true,hits:0,text:"        if(buffer.length > 0)",},{number:2097,tracked:false,hits:0,text:"        {",},{number:2098,tracked:true,hits:0,text:"            buffer[0] = '0';",},{number:2099,tracked:true,hits:0,text:"            return buffer[0..1];",},{number:2100,tracked:false,hits:0,text:"        }",},{number:2101,tracked:false,hits:0,text:"        else",},{number:2102,tracked:true,hits:0,text:"            return null;",},{number:2103,tracked:false,hits:0,text:"    }",},{number:2104,tracked:false,hits:0,text:"",},{number:2105,tracked:true,hits:84,text:"    const CHARS = \"0123456789\";",},{number:2106,tracked:false,hits:0,text:"",},{number:2107,tracked:true,hits:84,text:"    ptrdiff_t i = buffer.length;",},{number:2108,tracked:true,hits:436,text:"    while(i > 0 && num > 0)",},{number:2109,tracked:false,hits:0,text:"    {",},{number:2110,tracked:true,hits:144,text:"        buffer[--i] = CHARS[num % 10];",},{number:2111,tracked:true,hits:144,text:"        num /= 10;",},{number:2112,tracked:false,hits:0,text:"    }",},{number:2113,tracked:false,hits:0,text:"",},{number:2114,tracked:true,hits:84,text:"    return buffer[i..$];",},{number:2115,tracked:false,hits:0,text:"}",},{number:2116,tracked:false,hits:0,text:"///",},{number:2117,tracked:false,hits:0,text:"@(\"numToStrBase10\")",},{number:2118,tracked:false,hits:0,text:"unittest",},{number:2119,tracked:false,hits:0,text:"{",},{number:2120,tracked:true,hits:1,text:"    char[2] b;",},{number:2121,tracked:true,hits:1,text:"    assert(numToStrBase10(b, 32) == \"32\");",},{number:2122,tracked:false,hits:0,text:"}",},{number:2123,tracked:false,hits:0,text:"",},{number:2124,tracked:false,hits:0,text:"private NumT strToNum(NumT)(const(char)[] slice)",},{number:2125,tracked:false,hits:0,text:"{",},{number:2126,tracked:true,hits:53,text:"    NumT num;",},{number:2127,tracked:false,hits:0,text:"",},{number:2128,tracked:true,hits:543,text:"    foreach(i, ch; slice)",},{number:2129,tracked:false,hits:0,text:"    {",},{number:2130,tracked:true,hits:96,text:"        const exponent = slice.length - (i + 1);",},{number:2131,tracked:true,hits:96,text:"        const tens     = 10 ^^ exponent;",},{number:2132,tracked:true,hits:96,text:"        const chNum    = cast(NumT)(ch - '0');",},{number:2133,tracked:false,hits:0,text:"",},{number:2134,tracked:true,hits:96,text:"        if(tens == 0)",},{number:2135,tracked:true,hits:0,text:"            num += chNum;",},{number:2136,tracked:false,hits:0,text:"        else",},{number:2137,tracked:true,hits:96,text:"            num += chNum * tens;",},{number:2138,tracked:false,hits:0,text:"    }",},{number:2139,tracked:false,hits:0,text:"",},{number:2140,tracked:true,hits:53,text:"    return num;",},{number:2141,tracked:false,hits:0,text:"}",},{number:2142,tracked:false,hits:0,text:"///",},{number:2143,tracked:false,hits:0,text:"@(\"strToNum\")",},{number:2144,tracked:false,hits:0,text:"unittest",},{number:2145,tracked:false,hits:0,text:"{",},{number:2146,tracked:true,hits:1,text:"    assert(\"1\".strToNum!int == 1);",},{number:2147,tracked:true,hits:1,text:"    assert(\"11\".strToNum!int == 11);",},{number:2148,tracked:true,hits:1,text:"    assert(\"901\".strToNum!int == 901);",},{number:2149,tracked:false,hits:0,text:"}",},]},
                    ],
                    filename: "",
                },
                methods: {
                    getClass(line) {
                        if(!line.tracked)
                            return ""
                        else if(line.hits > 0)
                            return "covered"
                        else
                            return "uncovered"
                    }
                },
            })

            app.filename = app.files[0].file
        </script>
    </body>
</html>